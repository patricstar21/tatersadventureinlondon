<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <!-- CHANGE (cleanup): deduped OG/Twitter meta tags; fixed og:image:type to match asset -->
    <!-- Social preview metadata -->
    <meta property="og:title" content="Tater's Adventure Through London">
    <meta property="og:description" content="An endless runner about helping a lost dog find his way home. Built in collaboration with AI.">
    <meta property="og:image" content="https://patricstar21.github.io/tatersadventure/preview-v2.jpg">
    <meta property="og:image:secure_url" content="https://patricstar21.github.io/tatersadventure/preview.jpg">
    <meta property="og:image:type" content="image/jpeg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:url" content="https://patricstar21.github.io/tatersadventure/">
    <meta property="og:type" content="website">
    <meta property="fb:app_id" content="1234567890">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Tater's Adventure Through London">
    <meta name="twitter:description" content="An endless runner about helping a lost dog find his way home. Built in collaboration with AI.">
    <meta name="twitter:image" content="https://patricstar21.github.io/tatersadventure/preview.jpg">

    <!-- Favicon -->
    <link rel="icon" href="favicon.ico?v=1.1">
    <link rel="apple-touch-icon" href="preview.jpg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="description" content="A small endless runner about helping a lost dog find his way home through London.">
    <title>Tater's Adventure Through London</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        /* CHANGE (ambient): CSS variable for background motion speed factor */
        /* ambientMotionFactor = 1.0 is normal; < 1.0 is slower (e.g., 0.55 for calm pre-run) */
        /* Initial value matches AMBIENT_RAMP_START to prevent "sprint" on page load */
        :root {
            --ambient-motion-factor: 0.55;
        }

        /* iOS compositor flash prevention: explicit background at every layer */
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: relative;
            touch-action: manipulation;
            background: #87A5B8;
        }

        body {
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            background: #87A5B8;
            font-family: 'Fredoka One', 'Georgia', serif;
        }

        /* iOS compositor flash prevention: explicit background + GPU layer promotion + containment */
        .game-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #87A5B8;
            /* -webkit-transform: translateZ(0); */
            /* transform: translateZ(0); */
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }

        .sky {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 70%;
            background: linear-gradient(180deg, #6A8FA8 0%, #8AACBE 30%, #A8C4D4 60%, #C8DDE8 100%);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }

        .clouds {
            position: absolute;
            top: 20px;
            left: 0;
            width: 300%;
            height: 140px;
            animation: scroll-clouds calc(120s / var(--ambient-motion-factor, 1)) linear infinite;
            will-change: transform;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        .clouds.paused { animation-play-state: paused; }
        @keyframes scroll-clouds {
            0% { transform: translate3d(0, 0, 0); }
            100% { transform: translate3d(-66.6667%, 0, 0); }
        }
        .cloud {
            position: absolute;
            background: rgba(255,255,255,0.9);
            border-radius: 50px;
        }

        .landmarks-far {
            position: absolute;
            bottom: 32%;
            left: 0;
            width: 300%;
            height: 180px;
            animation: scroll-far calc(160s / var(--ambient-motion-factor, 1)) linear infinite;
            will-change: transform;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        .landmarks-far.paused { animation-play-state: paused; }
        @keyframes scroll-far {
            0% { transform: translate3d(0, 0, 0); }
            100% { transform: translate3d(-66.6667%, 0, 0); }
        }

        /* Atmospheric haze layer - static gradient between far skyline and mid layer */
        .atmospheric-haze {
            position: absolute;
            bottom: 28%;
            left: 0;
            width: 100%;
            height: 60px;
            background: linear-gradient(180deg,
                rgba(180, 200, 220, 0) 0%,
                rgba(180, 200, 220, 0.12) 40%,
                rgba(180, 200, 220, 0.18) 70%,
                rgba(180, 200, 220, 0.08) 100%
            );
            pointer-events: none;
            z-index: 1;
        }

        .landmarks-mid {
            position: absolute;
            bottom: 28%;
            left: 0;
            width: 300%;
            height: 160px;
            opacity: 0.92;
            animation: scroll-mid calc(100s / var(--ambient-motion-factor, 1)) linear infinite;
            will-change: transform;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        .landmarks-mid.paused { animation-play-state: paused; }
        @keyframes scroll-mid {
            0% { transform: translate3d(0, 0, 0); }
            100% { transform: translate3d(-66.6667%, 0, 0); }
        }

        .park-elements {
            position: absolute;
            bottom: 22%;
            left: 0;
            width: 300%;
            height: 130px;
            opacity: 0.88;
            animation: scroll-park calc(60s / var(--ambient-motion-factor, 1)) linear infinite;
            will-change: transform;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        .park-elements.paused { animation-play-state: paused; }
        @keyframes scroll-park {
            0% { transform: translate3d(0, 0, 0); }
            100% { transform: translate3d(-66.6667%, 0, 0); }
        }

        .grass {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30%;
            background: linear-gradient(180deg, #5A9A4A 0%, #4A8A3A 30%, #3A7A2A 100%);
        }

        .path {
            position: absolute;
            bottom: calc(9% - 4%);
            left: 0;
            width: 300%;
            height: 60px;
            background: linear-gradient(180deg, #D4C8B8 0%, #C4B8A8 30%, #B4A898 70%, #A49888 100%);
            border-top: 3px solid #8A7A6A;
            border-bottom: 3px solid #7A6A5A;
            animation: scroll-path calc(16s / var(--ambient-motion-factor, 1)) linear infinite;
            will-change: transform;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;

        }
        @media (max-width: 520px) {
  .path {
    bottom: calc(18% - 4%);
  }
}
        .path.paused { animation-play-state: paused; }
        @keyframes scroll-path {
    0% { transform: translate3d(0, 0, 0); }
    100% { transform: translate3d(-66.6667%, 0, 0); }
}


        .tater-container {
            position: absolute;
            left: 10%;
            bottom: 9%;
            z-index: 100;
            transition: bottom 0.05s linear;
        }

        /* Visual pass - Tater with consistent storybook shadow */
        .tater {
            width: 100px;
            height: 75px;
            filter: drop-shadow(1px 2px 3px rgba(0,0,0,0.4));
        }
        @media (min-width: 768px) {
            .tater { width: 120px; height: 90px; }
        }
        .tater.running {
            animation: tater-run 0.2s ease-in-out infinite;
        }
        @keyframes tater-run {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }
        .tater.hurt {
            animation: tater-hurt 0.5s ease-out;
        }
        /* Visual pass - hurt animation (compositor-safe: transform + opacity only) */
        @keyframes tater-hurt {
            0%, 100% { opacity: 1; transform: translateX(0); }
            20%, 60% { opacity: 0.7; transform: translateX(-4px); }
            40%, 80% { opacity: 0.85; transform: translateX(4px); }
        }
        .tater.healed {
            animation: tater-heal 0.5s ease-out;
        }
        /* Visual pass - heal animation (compositor-safe: transform + opacity only) */
        @keyframes tater-heal {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.08); }
        }

        /* ================================================================
           EMOTION v1 CSS (single source of truth) â€” Priority 3
           States: defeated, weary, tired, settled, hopeful
           Stacking: .tater.defeated.hopeful blends both transforms
           ================================================================ */

        /* Game-over polish - Part C: Tater's defeated state (compositor-safe: no filter transition) */
        .tater.defeated {
            animation: none !important;
            transform: translateY(8px) rotate(-5deg);
            opacity: 0.75;
            transition: transform 0.4s ease-out, opacity 0.4s ease-out;
        }
        .tater.defeated .tater-tail,
        .tater.defeated .tater-ear-left,
        .tater.defeated .tater-ear-right,
        .tater.defeated .tater-tongue {
            animation: none !important;
        }
        .tater.defeated .tater-tail {
            transform: rotate(-15deg) !important;
        }
        .tater.defeated .tater-tongue {
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        body.reduce-motion .tater.defeated {
            transition: none !important;
        }

        /* Priority 3: Emotional feedback - Settled state (milestone reached) */
        /* Brief calm beat: posture relaxes, tail wag slows, breathing steadies */
        .tater.settled {
            animation: tater-settle 0.8s ease-out forwards;
        }
        @keyframes tater-settle {
            0% { transform: translateY(0); }
            30% { transform: translateY(1px) scale(1.01); }
            60% { transform: translateY(0) scale(1.005); }
            100% { transform: translateY(0) scale(1); }
        }
        .tater.settled .tater-tail {
            animation: tail-wag-slow 0.6s ease-in-out infinite;
        }
        @keyframes tail-wag-slow {
            0%, 100% { transform: rotate(-4deg); }
            50% { transform: rotate(6deg); }
        }
        body.reduce-motion .tater.settled {
            animation: none !important;
        }
        body.reduce-motion .tater.settled .tater-tail {
            animation: none !important;
        }

        /* Priority 3: Emotional feedback - Weary state (mid-late run, subtle fatigue) */
        /* Subtler than tired: slightly reduced bounce, marginally slower tail */
        .tater.weary.running {
            animation: tater-run-weary 0.22s ease-in-out infinite;
        }
        @keyframes tater-run-weary {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }
        .tater.weary .tater-tail {
            animation: tail-wag-weary 0.4s ease-in-out infinite;
        }
        @keyframes tail-wag-weary {
            0%, 100% { transform: rotate(-6deg); }
            50% { transform: rotate(8deg); }
        }
        body.reduce-motion .tater.weary.running {
            animation: none !important;
        }
        body.reduce-motion .tater.weary .tater-tail {
            animation: none !important;
        }

        /* Priority 3: Emotional feedback - Tired state (late-run, determined) */
        /* Reduced bounce, slower pant, drooping ears, slower tail */
        .tater.tired.running {
            animation: tater-run-tired 0.25s ease-in-out infinite;
        }
        @keyframes tater-run-tired {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
        }
        .tater.tired .tater-tail {
            animation: tail-wag-tired 0.5s ease-in-out infinite;
        }
        @keyframes tail-wag-tired {
            0%, 100% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
        }
        .tater.tired .tater-ear-left {
            animation: ear-droop-left 0.4s ease-in-out infinite;
        }
        .tater.tired .tater-ear-right {
            animation: ear-droop-right 0.4s ease-in-out infinite 0.05s;
        }
        @keyframes ear-droop-left {
            0%, 100% { transform: rotate(2deg) translateY(1px); }
            50% { transform: rotate(0deg) translateY(2px); }
        }
        @keyframes ear-droop-right {
            0%, 100% { transform: rotate(-2deg) translateY(1px); }
            50% { transform: rotate(0deg) translateY(2px); }
        }
        .tater.tired.running .tater-tongue {
            animation: tongue-pant-tired 0.6s ease-in-out infinite;
        }
        @keyframes tongue-pant-tired {
            0%, 100% { transform: translateY(0) scaleY(1); }
            50% { transform: translateY(1px) scaleY(1.05); }
        }
        body.reduce-motion .tater.tired.running {
            animation: none !important;
        }
        body.reduce-motion .tater.tired .tater-tail,
        body.reduce-motion .tater.tired .tater-ear-left,
        body.reduce-motion .tater.tired .tater-ear-right,
        body.reduce-motion .tater.tired.running .tater-tongue {
            animation: none !important;
        }

        /* Priority 3: Emotional feedback - Hopeful state (game-over, subtle hope) */
        /* Very subtle lift of head/posture after defeat, implying "we'll try again" */
        .tater.hopeful {
            animation: tater-hopeful 0.8s ease-out forwards;
        }
        @keyframes tater-hopeful {
            0% { transform: translateY(8px) rotate(-5deg); }
            60% { transform: translateY(6px) rotate(-3deg); }
            100% { transform: translateY(7px) rotate(-4deg); }
        }
        .tater.hopeful .tater-tail {
            animation: tail-hopeful 1.2s ease-in-out;
        }
        @keyframes tail-hopeful {
            0%, 100% { transform: rotate(-15deg); }
            50% { transform: rotate(-8deg); }
        }
        body.reduce-motion .tater.hopeful {
            animation: none !important;
            transform: translateY(7px) rotate(-4deg);
        }
        body.reduce-motion .tater.hopeful .tater-tail {
            animation: none !important;
        }

        /* Priority 3: Defeated + Hopeful stacking - when hopeful is added after defeated */
        /* Override the defeated !important to allow hopeful animation to play */
        .tater.defeated.hopeful {
            animation: tater-hopeful 0.8s ease-out forwards !important;
        }
        .tater.defeated.hopeful .tater-tail {
            animation: tail-hopeful 1.2s ease-in-out !important;
        }
        body.reduce-motion .tater.defeated.hopeful {
            animation: none !important;
            transform: translateY(7px) rotate(-4deg);
        }
        body.reduce-motion .tater.defeated.hopeful .tater-tail {
            animation: none !important;
        }

        /* Tater enhanced animations - tail wag */
        .tater .tater-tail {
            transform-origin: 20px 35px;
            animation: tail-wag 0.3s ease-in-out infinite;
        }
        @keyframes tail-wag {
            0%, 100% { transform: rotate(-8deg); }
            50% { transform: rotate(12deg); }
        }

        /* Tater enhanced animations - ear flop */
        .tater .tater-ear-left {
            transform-origin: 92px 20px;
            animation: ear-flop-left 0.25s ease-in-out infinite;
        }
        .tater .tater-ear-right {
            transform-origin: 115px 18px;
            animation: ear-flop-right 0.25s ease-in-out infinite 0.05s;
        }
        @keyframes ear-flop-left {
            0%, 100% { transform: rotate(0deg) translateY(0); }
            50% { transform: rotate(-3deg) translateY(-1px); }
        }
        @keyframes ear-flop-right {
            0%, 100% { transform: rotate(0deg) translateY(0); }
            50% { transform: rotate(3deg) translateY(-1px); }
        }

        /* Tater enhanced animations - blink */
        .tater .tater-eyelid-left,
        .tater .tater-eyelid-right {
            animation: tater-blink 4s ease-in-out infinite;
        }
        .tater .tater-eyelid-right {
            animation-delay: 0.05s;
        }
        @keyframes tater-blink {
            0%, 92%, 100% { transform: scaleY(0); }
            94%, 98% { transform: scaleY(1); }
        }

        /* Tater enhanced animations - tongue pant */
        .tater.running .tater-tongue {
            animation: tongue-pant 0.4s ease-in-out infinite;
        }
        @keyframes tongue-pant {
            0%, 100% { transform: translateY(0) scaleY(1); }
            50% { transform: translateY(2px) scaleY(1.1); }
        }

        /* Tater enhanced - idle breathing when not running (only during active play) */
        /* Pre-run: Tater is static. Idle breathing starts after first run begins. */
        body.playing .tater:not(.running):not(.hurt):not(.healed) {
            animation: tater-idle 2s ease-in-out infinite;
        }
        @keyframes tater-idle {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .shadow {
            width: 60px;
            height: 10px;
            background: radial-gradient(ellipse, rgba(0,0,0,0.3) 0%, transparent 70%);
            border-radius: 50%;
            margin: 0 auto;
            margin-left: 20px;
            transition: transform 0.05s, opacity 0.05s;
        }

        .obstacles {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .obstacle, .powerup {
            position: absolute;
            z-index: 50;
        }

        /* Visual pass - inner sprite wrapper with storybook shadow */
        .sprite {
    width: 100%;
    height: 100%;
    /* Visual pass - consistent storybook shadow (single layer for perf) */
    filter: drop-shadow(1px 2px 2px rgba(0,0,0,0.35));
    transform: translate3d(0, 0, 0);
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
    will-change: transform, opacity;
}

        /* Flying objects polish - spawn-in animation (softened entry to reduce peripheral eye strain) */
        /* Pre-state: holds obstacle invisible until viewport entry triggers animation (high speed only) */
		.sprite.spawn-pending {
			opacity: 0;
			transform: translate3d(0, 0, 0) scale(1);
		}
        .sprite.spawning {
            /* Priority 3 Difficulty: Extended reveal delays visual certainty, not hitbox */
            animation: sprite-spawn 260ms ease-out forwards;
        }
		@keyframes sprite-spawn {
			0% { opacity: 0; transform: translate3d(0, 0, 0) scale(1); }
			100% { opacity: 1; transform: translate3d(0, 0, 0) scale(1); }
		}


        /* Flying objects polish - entry telegraph (brief attention-getting bob) */
        .sprite.telegraph {
            animation: sprite-telegraph 200ms ease-out;
        }
        /* Visual pass - telegraph animation (bob only; shadow inherited from .sprite) */
		@keyframes sprite-telegraph {
			0%, 100% { transform: translate3d(0, 0, 0); }
			50% { transform: translate3d(0, 0, 0); }
		}


        /* Flying objects polish - per-type idle animations */

        /* Balloon: gentle sway + vertical bob */
        .sprite.balloon-idle {
            animation: balloon-float 2.5s ease-in-out infinite;
        }
        @keyframes balloon-float {
            0%, 100% { transform: translate3d(0, 0, 0) rotate(-2deg); }
            25% { transform: translate3d(0, -3px, 0) rotate(0deg); }
            50% { transform: translate3d(0, -1px, 0) rotate(2deg); }
            75% { transform: translate3d(0, -4px, 0) rotate(0deg); }
        }

        /* Pigeon: subtle flap + bob */
        .sprite.pigeon-idle {
            animation: pigeon-bob 0.6s ease-in-out infinite;
        }
        @keyframes pigeon-bob {
            0%, 100% { transform: translate3d(0, 0, 0) scaleY(1); }
            50% { transform: translate3d(0, -2px, 0) scaleY(0.95); }
        }

        /* Thunder cloud: slight jitter */
        .sprite.thunder-idle {
            animation: thunder-jitter 0.15s ease-in-out infinite;
        }
        @keyframes thunder-jitter {
            0%, 100% { transform: translate3d(0, 0, 0); }
            25% { transform: translate3d(0, -1px, 0); }
            75% { transform: translate3d(0, 1px, 0); }
        }

        /* Vacuum: subtle vibration */
        .sprite.vacuum-idle {
            animation: vacuum-shake 0.08s linear infinite;
        }
        @keyframes vacuum-shake {
            0%, 100% { transform: translate3d(0, 0, 0); }
            50% { transform: translate3d(0, -1px, 0); }
        }

        /* Cat: subtle tail swish via slight bob */
        .sprite.cat-idle {
            animation: cat-prowl 0.8s ease-in-out infinite;
        }
        @keyframes cat-prowl {
            0%, 100% { transform: translate3d(0, 0, 0); }
            50% { transform: translate3d(0, -1px, 0); }
        }

        /* Squirrel: nervous twitch */
        .sprite.squirrel-idle {
            animation: squirrel-twitch 0.4s ease-in-out infinite;
        }
        @keyframes squirrel-twitch {
            0%, 80%, 100% { transform: translate3d(0, 0, 0) rotate(0deg); }
            40% { transform: translate3d(0, -2px, 0) rotate(-2deg); }
        }

        /* Skateboard: slight roll wobble */
        .sprite.skateboard-idle {
            animation: skateboard-roll 0.3s ease-in-out infinite;
        }
        @keyframes skateboard-roll {
            0%, 100% { transform: translate3d(0, 0, 0); }
            50% { transform: translate3d(0, -1px, 0); }
        }

        /* ROSTER UPDATE: Umbrella - tumbling drift */
        .sprite.umbrella-idle {
            animation: umbrella-tumble 1.5s ease-in-out infinite;
        }
        @keyframes umbrella-tumble {
            0%, 100% { transform: translate3d(0, 0, 0) rotate(-5deg); }
            25% { transform: translate3d(0, -4px, 0) rotate(0deg); }
            50% { transform: translate3d(0, -2px, 0) rotate(5deg); }
            75% { transform: translate3d(0, -5px, 0) rotate(2deg); }
        }

        /* ROSTER UPDATE: Frisbee - gentle spin wobble (inner only, no container rotation) */
        .sprite.frisbee-idle {
            animation: frisbee-wobble 0.8s ease-in-out infinite;
        }
        @keyframes frisbee-wobble {
            0%, 100% { transform: translate3d(0, 0, 0) scaleX(1); }
            25% { transform: translate3d(0, -2px, 0) scaleX(0.98); }
            50% { transform: translate3d(0, -1px, 0) scaleX(1); }
            75% { transform: translate3d(0, -3px, 0) scaleX(1.02); }
        }

        /* Default idle for others (mailman, vet, cone): subtle presence bob */
        .sprite.default-idle {
            animation: default-bob 1.2s ease-in-out infinite;
        }
        @keyframes default-bob {
            0%, 100% { transform: translate3d(0, 0, 0); }
            50% { transform: translate3d(0, -1px, 0); }
        }

        /* Flying objects polish - depth cues: ground shadow for obstacles */
        .obstacle::after {
            /* Disabled for perf: gradient shadow was paint-heavy on moving elements */
            display: none;
        }

        /* Powerup styling */
        .powerup {
            z-index: 60;
        }

        /* Flying objects polish - bone powerup: gentle float + compositor-safe glow */
        .sprite.bone-idle {
            position: relative;
            animation: bone-float 1.5s ease-in-out infinite;
        }
        .sprite.bone-idle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 120%;
            height: 120%;
            transform: translate(-50%, -50%);
            background: radial-gradient(ellipse at center, rgba(255,215,0,0.5) 0%, rgba(255,215,0,0) 70%);
            pointer-events: none;
            opacity: 0.8; /* Static glow (animation removed for perf) */
            z-index: -1;
        }
        @keyframes bone-float {
            0%, 100% { transform: translate3d(0, 0, 0) rotate(-1deg); }
            50% { transform: translate3d(0, -5px, 0) rotate(1deg); }
        }

        .ui-top {
            position: fixed;
            top: max(10px, env(safe-area-inset-top));
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0 max(15px, env(safe-area-inset-left)) 0 max(15px, env(safe-area-inset-right));
            z-index: 500;
        }

        .lives-container {
            display: flex;
            gap: 4px;
            background: rgba(255,252,245,0.95);
            padding: 8px 12px;
            border-radius: 12px;
            border: 2px solid #A08060;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }
        .life-bone {
            width: 28px;
            height: 18px;
            transition: all 0.3s ease;
        }
        @media (min-width: 768px) {
            .life-bone { width: 34px; height: 20px; }
            .lives-container { gap: 6px; padding: 10px 16px; }
        }
        .life-bone.lost {
            opacity: 0.2;
            filter: grayscale(1) brightness(1.5);
        }

        .controls {
            display: flex;
            gap: 8px;
        }
        .btn {
            background: linear-gradient(180deg, #FFF8F0 0%, #F0E8E0 100%);
            border: 2px solid #A08060;
            border-radius: 10px;
            padding: 8px 14px;
            font-family: 'Fredoka One', 'Georgia', serif;
            font-size: 14px;
            color: #5A4A3A;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(0,0,0,0.2);
            transition: all 0.15s ease;
        }
        @media (min-width: 768px) {
            .btn { padding: 10px 20px; font-size: 16px; }
        }
        .btn:hover { transform: translateY(-2px); }
        .btn:active { transform: translateY(1px); }

        .score-display {
            position: fixed;
            top: max(60px, calc(env(safe-area-inset-top) + 50px));
            left: max(15px, env(safe-area-inset-left));
            background: rgba(255,252,245,0.95);
            padding: 8px 16px;
            border-radius: 12px;
            border: 2px solid #A08060;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            font-size: 14px;
            color: #5A4A3A;
            z-index: 500;
        }
        .score-display span {
            font-size: 22px;
            color: #3A7A3A;
        }
        @media (min-width: 768px) {
            .score-display { font-size: 16px; padding: 10px 20px; }
            .score-display span { font-size: 26px; }
        }

        /* Priority 3: Developer debug HUD (hidden by default, toggle with D key) */
        .debug-hud {
            display: none;
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.75);
            color: #0f0;
            font-family: monospace;
            font-size: 11px;
            padding: 8px 10px;
            border-radius: 4px;
            z-index: 9999;
            pointer-events: none;
            line-height: 1.4;
        }
        .debug-hud.show { display: block; }
        body.high-contrast .debug-hud {
            background: rgba(0,0,0,0.95);
            color: #fff;
            border: 1px solid #fff;
        }

        .game-title {
            position: fixed;
            top: max(12px, env(safe-area-inset-top));
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Fredoka One', cursive;
            font-size: 12px;
            color: #4A6A4A;
            text-shadow: 2px 2px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff;
            z-index: 500;
            white-space: nowrap;
        }
        @media (min-width: 500px) {
            .game-title { font-size: 16px; }
        }
        @media (min-width: 768px) {
            .game-title { font-size: 24px; }
        }

        /* Mobile UI - responsive header and compact controls */
        /* CHANGE (cleanup): removed conflicting 480px mobile HUD rules; 520px block is source of truth */
        /* .game-title and .score-display positioning moved to @media (max-width: 520px) block */
        @media (max-width: 480px) {
            .ui-top {
                padding: 0 max(8px, env(safe-area-inset-right)) 0 max(8px, env(safe-area-inset-left));
            }
            .lives-container {
                padding: 6px 8px;
                gap: 2px;
            }
            .life-bone {
                width: 22px;
                height: 14px;
            }
            .controls {
                gap: 6px;
            }
            /* Mobile UI - hide text labels, show icons only */
            .btn {
                min-width: 44px;
                min-height: 44px;
                padding: 10px;
                font-size: 18px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .btn-label { display: none; }
            .btn-icon { display: inline; }
            /* Mobile UI - more menu styling */
            .mobile-more-btn {
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .mobile-menu {
                display: none;
                position: absolute;
                top: 100%;
                right: 0;
                margin-top: 8px;
                background: rgba(255,252,245,0.98);
                border: 2px solid #A08060;
                border-radius: 12px;
                box-shadow: 0 4px 16px rgba(0,0,0,0.25);
                padding: 10px;
                flex-direction: column;
                gap: 10px;
                z-index: 600;
            }
            .mobile-menu.show {
                display: flex;
            }
            .mobile-menu .btn {
                width: 100%;
                min-width: 130px;
                justify-content: flex-start;
                padding: 12px 16px;
            }
            .mobile-menu .btn-label { display: inline; }
            .mobile-menu .btn-icon { margin-right: 10px; }
            /* REMOVED: .score-display positioning - now in 520px block */
            /* Mobile UI - hide hint on very small screens */
            .hint {
                font-size: 10px;
                bottom: 8%;
            }
        }
        /* Mobile UI - desktop shows labels, hides mobile elements */
        @media (min-width: 481px) {
            .btn-icon { display: none; }
            .btn-label { display: inline; }
            .mobile-more-btn { display: none !important; }
            .mobile-menu { display: none !important; }
            #resetBtnMobile { display: none !important; }
        }
        /* Mobile UI - mobile hides desktop reset button */
        @media (max-width: 480px) {
            #resetBtn { display: none !important; }
        }
        /* Mobile UI - Extra compact breakpoint for very small screens (360px and below) */
        @media (max-width: 360px) {
            .ui-top {
                padding: 0 max(4px, env(safe-area-inset-right)) 0 max(4px, env(safe-area-inset-left));
            }
            .lives-container {
                padding: 4px 6px;
                gap: 1px;
                border-radius: 8px;
            }
            .life-bone {
                width: 18px;
                height: 12px;
            }
            .controls {
                gap: 4px;
            }
            .btn {
                min-width: 40px;
                min-height: 40px;
                padding: 8px;
                font-size: 16px;
            }
            /* REMOVED: .game-title and .score-display rules - now in consolidated 360px block below */
            /* Compact hint */
            .hint {
                font-size: 9px;
                padding: 6px 12px;
            }
            /* Compact mobile menu */
            .mobile-menu {
                padding: 8px;
                gap: 8px;
            }
            .mobile-menu .btn {
                min-width: 110px;
                padding: 10px 12px;
                font-size: 14px;
            }
        }
        /* Mobile UI - controls wrapper for menu positioning */
        .controls-wrapper {
            position: relative;
            display: flex;
            align-items: flex-start;
        }

        .jump-indicator {
            position: fixed;
            bottom: 20%;
            left: 8%;
            width: 10px;
            height: 0;
            max-height: 60px;
            background: linear-gradient(180deg, #90EE90 0%, #32CD32 100%);
            border-radius: 5px;
            z-index: 150;
            box-shadow: 0 0 10px rgba(50,205,50,0.5);
            transition: height 0.03s linear;
        }

        .hint {
            position: fixed;
            bottom: max(15px, env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,252,245,0.95);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 12px;
            color: #5A4A3A;
            z-index: 500;
            border: 2px solid #A08060;
            white-space: nowrap;
            opacity: 1;
            transition: opacity 0.4s ease-out;
        }
        /* v1.1.x: fully remove hint when hidden */
        .hint.hidden {
            display: none;
        }
        /* Onboarding - Toast mode for temporary tips */
        .hint.toast {
            animation: toast-appear 0.3s ease-out;
        }
        .hint.toast-out {
            animation: toast-disappear 0.4s ease-out forwards;
        }
        @keyframes toast-appear {
            from { opacity: 0; transform: translateX(-50%) translateY(10px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        @keyframes toast-disappear {
            from { opacity: 1; transform: translateX(-50%) translateY(0); }
            to { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }
        body.reduce-motion .hint.toast,
        body.reduce-motion .hint.toast-out {
            animation: none !important;
        }
        @media (min-width: 768px) {
            .hint { font-size: 14px; padding: 12px 28px; }
        }

        /* iOS compositor stability: promote full-screen overlays to GPU layers */
        .damage-flash, .heal-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            z-index: 400;
            transition: opacity 0.1s;
            transform: translate3d(0, 0, 0);
            will-change: opacity;
        }
        .damage-flash { background: rgba(255,80,80,0.3); }
        .heal-flash { background: rgba(80,255,80,0.25); }
        .damage-flash.show, .heal-flash.show { opacity: 1; }

        /* Step 3 juice - screen shake animation */
        .game-container.shake {
            animation: screen-shake 100ms ease-out;
        }
        @keyframes screen-shake {
    0%, 100% { transform: translate3d(0, 0, 0); }
    20% { transform: translate3d(-3px, 1px, 0); }
    40% { transform: translate3d(3px, -1px, 0); }
    60% { transform: translate3d(-2px, 1px, 0); }
    80% { transform: translate3d(2px, -1px, 0); }
}


        /* Step 3 juice - floating text for heal */
        .float-text {
            position: absolute;
            font-family: 'Fredoka One', cursive;
            font-size: 18px;
            color: #44DD44;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3), 0 0 8px rgba(68,255,68,0.5);
            pointer-events: none;
            z-index: 200;
            animation: float-up 600ms ease-out forwards;
        }
        @keyframes float-up {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-40px) scale(1.2); }
        }

        /* Step 3 juice - bone pop animation on collect */
        .sprite.collected {
            animation: bone-pop 150ms ease-out forwards !important;
        }
        @keyframes bone-pop {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.8; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* CHANGE (mobile): center game-over modal reliably on iOS */
        /* Overlay show/hide: .overlay.show is the SINGLE source of truth for display toggle */
        .overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    display: flex;
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    transform: translate3d(0,0,0);
    -webkit-transform: translate3d(0,0,0);
    will-change: opacity;

    justify-content: center;
    align-items: center;
    z-index: 1000;

    /* iOS centering stability */
    min-height: 100vh;
    min-height: 100svh;
    padding: max(20px, env(safe-area-inset-top))
             max(16px, env(safe-area-inset-right))
             max(20px, env(safe-area-inset-bottom))
             max(16px, env(safe-area-inset-left));

    /* iOS compositor stability */
    -webkit-transform: translate3d(0, 0, 0);
    transform: translate3d(0, 0, 0);
    will-change: opacity;
}

.overlay.show {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
}


        /* Single source of truth for overlay visibility */
        /* CHANGE (mobile): center game-over modal reliably on iOS */
        .overlay-content {
            background: linear-gradient(180deg, #FFF8F0 0%, #F0E8E0 100%);
            padding: 30px 40px;
            border-radius: 20px;
            border: 3px solid #A08060;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            max-width: 90%;
            /* Mobile: prevent clipping on small screens */
            max-height: calc(100svh - 40px);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        @media (min-width: 768px) {
            .overlay-content { padding: 45px 65px; max-height: none; overflow-y: visible; }
        }
        .overlay-title {
            font-family: 'Fredoka One', cursive;
            font-size: 32px;
            color: #4A6A4A;
            margin-bottom: 12px;
        }
        @media (min-width: 768px) {
            .overlay-title { font-size: 40px; }
        }
        .overlay-score {
            font-size: 18px;
            color: #5A4A3A;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        .overlay-btn {
            background: linear-gradient(180deg, #6AB06A 0%, #5A9A5A 100%);
            color: white;
            border: 3px solid #4A8A4A;
            padding: 14px 40px;
            font-family: 'Fredoka One', cursive;
            font-size: 20px;
            border-radius: 12px;
            cursor: pointer;
            margin: 8px;
            transition: all 0.15s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }
        .overlay-btn:hover, .overlay-btn:active {
            transform: scale(1.05);
            background: linear-gradient(180deg, #7AC07A 0%, #6AB06A 100%);
        }
        .overlay-btn.secondary {
            background: linear-gradient(180deg, #8A8A9A 0%, #6A6A7A 100%);
            border-color: #5A5A6A;
            font-size: 16px;
            padding: 10px 28px;
        }
        .overlay-btn.secondary:hover, .overlay-btn.secondary:active {
            background: linear-gradient(180deg, #9A9AAA 0%, #7A7A8A 100%);
        }

        /* Step 4 tutorial - tutorial overlay styling */
        .tutorial-tips {
            text-align: left;
            margin: 15px 0 20px 0;
        }
        .tutorial-tip {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 12px 0;
            font-size: 16px;
            color: #5A4A3A;
        }
        @media (min-width: 768px) {
            .tutorial-tip { font-size: 18px; }
        }
        .tutorial-tip-icon {
            font-size: 24px;
            min-width: 32px;
            text-align: center;
        }

        /* Share polish - About button styling */
        .about-btn {
            position: fixed;
            bottom: max(15px, env(safe-area-inset-bottom));
            right: max(15px, env(safe-area-inset-right));
            width: 36px;
            height: 36px;
            background: rgba(255,252,245,0.9);
            border: 2px solid #A08060;
            border-radius: 50%;
            font-family: 'Georgia', serif;
            font-size: 18px;
            font-style: italic;
            font-weight: bold;
            color: #5A4A3A;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }
        .about-btn:hover { transform: scale(1.1); }
        .about-btn:active { transform: scale(0.95); }
        @media (max-width: 480px) {
            .about-btn {
                width: 32px;
                height: 32px;
                font-size: 16px;
            }
        }

        /* Share polish - Version string styling */
        .version-string {
            position: fixed;
            bottom: max(8px, env(safe-area-inset-bottom));
            left: max(10px, env(safe-area-inset-left));
            font-family: 'Fredoka One', cursive;
            font-size: 10px;
            color: rgba(90, 74, 58, 0.5);
            z-index: 100;
            pointer-events: none;
        }

        /* Share polish - About modal content styling */
        .about-content {
            max-width: 320px;
        }
        .about-description {
            font-size: 16px;
            color: #5A4A3A;
            margin: 15px 0;
            line-height: 1.5;
        }
        .about-credits {
            font-size: 14px;
            color: #7A6A5A;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #D0C0B0;
        }
        .about-credits strong {
            color: #5A4A3A;
        }
        .about-dedication {
            font-style: italic;
            margin-top: 8px;
            color: #8A7A6A;
        }

        /* Accessibility - Settings button styling */
        .settings-btn {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            width: 100%;
        }
        .settings-btn .btn-icon { margin-right: 10px; }

        /* Accessibility - Settings panel styling */
        .settings-content {
            max-width: 340px;
            text-align: left;
        }
        .settings-section {
            margin: 15px 0;
        }
        .settings-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid #D0C0B0;
        }
        .settings-toggle:last-child {
            border-bottom: none;
        }
        .settings-toggle-label {
            font-size: 15px;
            color: #5A4A3A;
        }
        .settings-toggle-desc {
            font-size: 11px;
            color: #8A7A6A;
            margin-top: 2px;
        }
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 28px;
            flex-shrink: 0;
            margin-left: 12px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #C0B0A0;
            border-radius: 28px;
            transition: 0.2s;
            border: 2px solid #A08060;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 2px;
            bottom: 2px;
            background: white;
            border-radius: 50%;
            transition: 0.2s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .toggle-switch input:checked + .toggle-slider {
            background: #6AB06A;
            border-color: #4A8A4A;
        }
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(22px);
        }
        .settings-keyboard {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #D0C0B0;
        }
        .settings-keyboard-title {
            font-size: 14px;
            font-weight: bold;
            color: #5A4A3A;
            margin-bottom: 8px;
        }
        .settings-keyboard-item {
            font-size: 12px;
            color: #7A6A5A;
            margin: 4px 0;
        }
        .settings-keyboard-item kbd {
            background: #E8E0D8;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #C0B0A0;
            font-family: monospace;
            font-size: 11px;
        }

        /* Accessibility - Reduce Motion mode */
        body.reduce-motion .clouds,
        body.reduce-motion .landmarks-far,
        body.reduce-motion .landmarks-mid,
        body.reduce-motion .park-elements,
        body.reduce-motion .path {
            animation-duration: 200s !important;
        }
        body.reduce-motion .tater-tail,
        body.reduce-motion .tater-ear-left,
        body.reduce-motion .tater-ear-right,
        body.reduce-motion .tater-tongue {
            animation: none !important;
        }
        body.reduce-motion .tater-eyelid-left,
        body.reduce-motion .tater-eyelid-right {
            animation: none !important;
        }
        body.reduce-motion .tater.running {
            animation: none !important;
        }
        body.reduce-motion .tater:not(.running):not(.hurt):not(.healed) {
            animation: none !important;
        }
        body.reduce-motion .sprite.spawn-pending,
        body.reduce-motion .sprite.spawning,
        body.reduce-motion .sprite.telegraph {
            animation: none !important;
            opacity: 1 !important;
            transform: translate3d(0, 0, 0) scale(1) !important; /* Explicit end state to prevent snap */
        }
        body.reduce-motion .powerup {
            animation: none !important;
        }
        body.reduce-motion .damage-flash,
        body.reduce-motion .heal-flash {
            animation: none !important;
            opacity: 0 !important;
        }
        body.reduce-motion .float-text {
            animation: none !important;
        }

        /* Accessibility - Reduce Motion: Disable ALL obstacle/sprite idle animations */
        /* This catches balloon-idle, pigeon-idle, thunder-idle, vacuum-idle, cat-idle,
           squirrel-idle, skateboard-idle, umbrella-idle, frisbee-idle, default-idle, etc. */
        body.reduce-motion .sprite[class*="-idle"] {
            animation: none !important;
            transform: none !important;
        }
        /* Accessibility - Reduce Motion: Bone powerup - disable float/glow but keep visible */
        body.reduce-motion .sprite.bone-idle {
            animation: none !important;
            transform: none !important;
        }
        body.reduce-motion .sprite.bone-idle::after {
            animation: none !important;
            opacity: 0.5 !important;
        }
        /* Accessibility - Reduce Motion: Explicitly disable rapid jitter/shake animations */
        body.reduce-motion .sprite.thunder-idle,
        body.reduce-motion .sprite.vacuum-idle {
            animation: none !important;
            transform: none !important;
        }

        /* CHANGE (high-speed-visual): Dampen noisy idle animations at high speed to reduce eye strain */
        /* Only active when score >= 1000 AND reduce-motion is NOT enabled */
        body.high-speed .sprite.thunder-idle {
            animation-duration: 0.3s; /* 2x slower (was 0.15s) */
        }
        body.high-speed .sprite.vacuum-idle {
            animation-duration: 0.2s; /* 2.5x slower (was 0.08s) */
        }
        body.high-speed .sprite.skateboard-idle {
            animation-duration: 0.6s; /* 2x slower (was 0.3s) */
        }
        /* Dampened keyframes with reduced amplitude for high-speed mode */
        @keyframes thunder-jitter-damped {
            0%, 100% { transform: translate3d(0, 0, 0); }
            50% { transform: translate3d(0, -1px, 0); }
        }
        @keyframes vacuum-shake-damped {
            0%, 100% { transform: translate3d(0, 0, 0); }
            50% { transform: translate3d(0, -0.5px, 0); }
        }
        @keyframes skateboard-roll-damped {
            0%, 100% { transform: translate3d(0, 0, 0); }
            50% { transform: translate3d(0, 1.5px, 0); } /* 25% reduced (was 2px) */
        }
        body.high-speed .sprite.thunder-idle {
            animation-name: thunder-jitter-damped;
            animation-duration: 0.3s;
        }
        body.high-speed .sprite.vacuum-idle {
            animation-name: vacuum-shake-damped;
            animation-duration: 0.2s;
        }
        body.high-speed .sprite.skateboard-idle {
            animation-name: skateboard-roll-damped;
            animation-duration: 0.6s;
        }

        /* Accessibility - High Contrast mode */
        body.high-contrast .game-title {
            background: rgba(0, 0, 0, 0.8) !important;
            color: #FFFFFF !important;
            text-shadow: none !important;
            padding: 6px 14px !important;
            border-radius: 8px !important;
            font-weight: bold;
        }
        body.high-contrast .score-display {
            background: rgba(0, 0, 0, 0.85) !important;
            color: #FFFFFF !important;
            border-color: #FFFFFF !important;
        }
        body.high-contrast .score-display span {
            color: #90FF90 !important;
        }
        body.high-contrast .lives-container {
            background: rgba(0, 0, 0, 0.85) !important;
            border-color: #FFFFFF !important;
        }
        body.high-contrast .hint {
            background: rgba(0, 0, 0, 0.8) !important;
            color: #FFFFFF !important;
            padding: 6px 12px !important;
            border-radius: 6px !important;
        }
        body.high-contrast .btn {
            background: #FFFFFF !important;
            color: #000000 !important;
            border-color: #000000 !important;
            font-weight: bold;
        }
        body.high-contrast .version-string {
            color: rgba(255, 255, 255, 0.7) !important;
        }
        /* Journey framing - High contrast mode compatibility */
        body.high-contrast .location-display {
            background: rgba(0, 0, 0, 0.85) !important;
            color: #FFFFFF !important;
            border-color: #FFFFFF !important;
        }
        body.high-contrast .location-display .location-name {
            color: #90FF90 !important;
        }
        body.high-contrast .location-display .location-progress {
            color: #CCCCCC !important;
        }
        body.high-contrast .milestone-banner {
            background: rgba(0, 0, 0, 0.95) !important;
            color: #FFFFFF !important;
            border-color: #90FF90 !important;
        }
        body.high-contrast .milestone-banner .milestone-label {
            color: #CCCCCC !important;
        }
        body.high-contrast .journey-result {
            background: rgba(0, 100, 0, 0.3) !important;
            border-color: #90FF90 !important;
        }
        body.high-contrast .journey-result .journey-label {
            color: #CCCCCC !important;
        }
        body.high-contrast .journey-result .journey-location {
            color: #90FF90 !important;
        }
        body.high-contrast .journey-result .journey-best {
            color: #AAAAAA !important;
        }
        body.high-contrast .journey-result .journey-best.new-best {
            color: #FFD700 !important;
        }

        /* CHANGE (UI): Visual hierarchy & pacing - Part A: De-emphasize non-critical UI during active play */
        /* Title stays fully visible on all screen sizes; only about/version/extra buttons fade */
        .game-title,
        .about-btn,
        .version-string,
        .controls .btn:not(#pauseBtn):not(#muteBtn) {
            transition: opacity 0.3s ease;
        }
        body.playing .about-btn,
        body.playing .version-string,
        body.playing .controls .btn:not(#pauseBtn):not(#muteBtn) {
            opacity: 0.5;
        }
        /* CHANGE (UI): Desktop title always fully visible during play */
        @media (min-width: 521px) {
            body.playing .game-title {
                opacity: 1 !important;
            }
        }
        /* CHANGE (visual): Reduce HUD noise during play - score slightly softer than journey */
        .score-display {
            transition: opacity 0.3s ease;
        }
        body.playing .score-display {
            opacity: 0.75;
        }
        /* Journey framing - Location display stays prominent (story focus) */
        .location-display {
            transition: opacity 0.3s ease;
        }
        body.playing .location-display {
            opacity: 0.92;
        }
        /* CHANGE (visual): Mute/pause softer during play - Tater is priority */
        body.playing .controls #muteBtn,
        body.playing .controls #pauseBtn {
            opacity: 0.7;
        }
        /* Visual hierarchy & pacing - Reduce motion: instant transitions */
        body.reduce-motion .game-title,
        body.reduce-motion .about-btn,
        body.reduce-motion .version-string,
        body.reduce-motion .controls .btn,
        body.reduce-motion .location-display,
        body.reduce-motion .score-display {
            transition: none !important;
        }

        /* Visual hierarchy & pacing - Part B: Pre-run prompt */
        .start-prompt {
            position: fixed;
            bottom: 25%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Fredoka One', cursive;
            font-size: 18px;
            color: #5A4A3A;
            background: rgba(255,252,245,0.95);
            padding: 12px 24px;
            border-radius: 20px;
            border: 2px solid #A08060;
            z-index: 500;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .start-prompt.show {
            opacity: 1;
        }
        body.reduce-motion .start-prompt {
            transition: none !important;
        }
        @media (min-width: 768px) {
            .start-prompt { font-size: 22px; padding: 14px 32px; }
        }

        /* Visual hierarchy & pacing - Part C: Game over overlay fade-in */
        /* CHANGE (cleanup): unified overlay show/hide to single selector to prevent mobile centering drift */
        /* Display toggle uses .overlay.show (generic); #gameOverOverlay adds opacity fade only */
        #gameOverOverlay {
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        #gameOverOverlay.show {
            /* display: flex inherited from .overlay.show - don't duplicate */
            opacity: 1;
        }
        /* Visual hierarchy & pacing - Immediate display for reduce-motion */
        body.reduce-motion #gameOverOverlay {
            transition: none !important;
        }
        body.reduce-motion #gameOverOverlay.show {
            opacity: 1;
        }

        /* Game-over polish - Part B: Cinematic framing (dim overlay, no filter for iOS stability) */
        .game-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.35);
            pointer-events: none;
            opacity: 0;
            z-index: 100;
            transition: opacity 0.5s ease-out;
            transform: translate3d(0, 0, 0);
            will-change: opacity;
        }
        .game-container.defeat-cinematic::after {
            opacity: 1;
        }
        body.reduce-motion .game-container::after {
            transition: none !important;
        }

        /* Game-over polish - Part B: Vignette overlay */
        /* iOS compositor stability: promote to GPU layer to prevent flash */
        .vignette-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.5) 100%);
            z-index: 450;
            transition: opacity 0.5s ease-out;
            transform: translate3d(0, 0, 0);
            will-change: opacity;
        }
        .vignette-overlay.show {
            opacity: 1;
        }
        body.reduce-motion .vignette-overlay {
            transition: none !important;
        }

        /* Game-over polish - Part D: Enhanced overlay styling */
        .game-over-message {
            font-size: 14px;
            color: #7A6A5A;
            margin-bottom: 8px;
            font-style: italic;
        }
        .final-score-display {
            font-size: 42px;
            font-family: 'Fredoka One', cursive;
            color: #4A6A4A;
            margin: 10px 0;
        }
        .best-score-display {
            font-size: 14px;
            color: #8A7A6A;
            margin-bottom: 16px;
        }
        .best-score-display.new-best {
            color: #DAA520;
            font-weight: bold;
        }
        @media (min-width: 768px) {
            .final-score-display { font-size: 52px; }
            .game-over-message { font-size: 16px; }
            .best-score-display { font-size: 16px; }
        }

        /* Journey framing - Location display styling */
        .location-display {
            position: fixed;
            top: max(60px, calc(env(safe-area-inset-top) + 50px));
            right: max(15px, env(safe-area-inset-right));
            background: rgba(255,252,245,0.95);
            padding: 6px 12px;
            border-radius: 10px;
            border: 2px solid #A08060;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            font-size: 11px;
            color: #5A4A3A;
            z-index: 500;
            text-align: right;
            max-width: 140px;
        }
        .location-display .location-name {
            font-size: 13px;
            font-weight: bold;
            color: #4A6A4A;
            display: block;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .location-display .location-progress {
            font-size: 10px;
            color: #7A6A5A;
            margin-top: 2px;
        }
        @media (min-width: 768px) {
            .location-display { font-size: 12px; padding: 8px 14px; max-width: 160px; }
            .location-display .location-name { font-size: 14px; }
            .location-display .location-progress { font-size: 11px; }
        }
        /* CHANGE (mobile HUD): consolidated single-source mobile layout rules */
        /* Layout: Row 1 = lives + buttons | Row 2 = Title (primary) | Row 3 = Location | Row 4 = Score */
        /* Title during play: opacity 0.7 (subtle but readable). Location: no truncation. */
        @media (max-width: 520px) {
            /* Mobile title hierarchy: Title is PRIMARY, below .ui-top with comfortable gap */
            .game-title {
                top: max(74px, calc(env(safe-area-inset-top) + 66px));
                /* Stable base size - no font-size animation (causes reflow/pop) */
                font-size: 15px;
                background: rgba(255,255,255,0.95);
                padding: 8px 16px;
                border-radius: 10px;
                border: 2px solid transparent;
                box-shadow: 0 3px 12px transparent;
                z-index: 502;
                /* Transform-based scaling avoids layout reflow */
                transform-origin: center center;
                /* Smooth transition: transform + opacity first, then decorative fade */
                transition: transform 320ms ease-out,
                            opacity 280ms ease-out,
                            border-color 400ms ease-out 80ms,
                            box-shadow 400ms ease-out 80ms;
            }
            /* Respect reduce-motion: disable title transitions */
            body.reduce-motion .game-title {
                transition: none;
            }
            /* Pre-run: title is HERO lockup - uses scale for size, not font-size */
            body:not(.playing) .game-title {
                opacity: 1;
                transform: translateX(-50%) scale(1.5);
                font-weight: 900;
                letter-spacing: 0.3px;
                border-color: rgba(160,128,96,0.55);
                box-shadow: 0 4px 16px rgba(74,60,40,0.22);
            }
            /* During play: scale down smoothly, decorative elements fade */
            body.playing .game-title {
                opacity: 0.85;
                transform: translateX(-50%) scale(1);
                font-weight: inherit;
                letter-spacing: normal;
                border-color: transparent;
                box-shadow: 0 2px 8px transparent;
            }
            /* Location bar sits below title with clear gap */
            .location-display {
                position: fixed;
                top: max(120px, calc(env(safe-area-inset-top) + 112px));
                left: max(8px, env(safe-area-inset-left));
                right: max(8px, env(safe-area-inset-right));
                max-width: none;
                width: auto;
                padding: 6px 12px;
                font-size: 11px;
                border-radius: 8px;
                text-align: center;
                display: flex;
                justify-content: center;
                align-items: center;
                gap: 8px;
            }
            .location-display .location-name {
                font-size: 12px;
                white-space: normal;
                overflow: visible;
                text-overflow: clip;
                display: inline;
                line-height: 1.2;
            }
            .location-display .location-progress {
                font-size: 10px;
                display: inline;
                opacity: 0.8;
            }
            /* Score below location bar */
            .score-display {
                top: max(160px, calc(env(safe-area-inset-top) + 152px));
            }
        }
        /* 360px: Same hierarchy (Title > Location > Score), slightly tighter but still comfortable */
        @media (max-width: 360px) {
            .game-title {
                top: max(68px, calc(env(safe-area-inset-top) + 60px));
                font-size: 12px;
                padding: 6px 12px;
            }
            /* Pre-run: hero scale slightly smaller on tiny screens */
            body:not(.playing) .game-title {
                transform: translateX(-50%) scale(1.4);
                border-color: rgba(160,128,96,0.55);
                box-shadow: 0 3px 12px rgba(74,60,40,0.18);
            }
            /* During play: same smooth scale-down */
            body.playing .game-title {
                transform: translateX(-50%) scale(1);
                border-color: transparent;
                box-shadow: 0 2px 8px transparent;
            }
            .location-display {
                top: max(110px, calc(env(safe-area-inset-top) + 102px));
                padding: 4px 8px;
                font-size: 9px;
                gap: 6px;
            }
            .location-display .location-name { font-size: 10px; }
            .location-display .location-progress { font-size: 8px; }
            .score-display {
                top: max(144px, calc(env(safe-area-inset-top) + 136px));
                padding: 4px 10px;
                font-size: 11px;
            }
        }

        /* Journey framing - Milestone banner styling */
        .milestone-banner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,252,245,0.98);
            padding: 12px 24px;
            border-radius: 16px;
            border: 3px solid #4A8A4A;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            font-family: 'Fredoka One', cursive;
            font-size: 18px;
            color: #4A6A4A;
            z-index: 550;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease-out;
        }
        .milestone-banner.show {
            opacity: 1;
        }
        .milestone-banner .milestone-label {
            font-size: 12px;
            color: #7A6A5A;
            font-weight: normal;
        }
        body.reduce-motion .milestone-banner {
            transition: none !important;
        }
        @media (min-width: 768px) {
            .milestone-banner { font-size: 22px; padding: 16px 32px; }
            .milestone-banner .milestone-label { font-size: 14px; }
        }
        @media (max-width: 480px) {
            .milestone-banner { font-size: 16px; padding: 10px 20px; }
            .milestone-banner .milestone-label { font-size: 11px; }
        }

        /* Journey framing - Game over journey display */
        .journey-result {
            margin: 12px 0;
            padding: 12px 16px;
            background: rgba(74, 138, 74, 0.1);
            border-radius: 12px;
            border: 2px solid rgba(74, 138, 74, 0.3);
        }
        .journey-result .journey-label {
            font-size: 12px;
            color: #7A6A5A;
            margin-bottom: 4px;
        }
        .journey-result .journey-location {
            font-size: 20px;
            font-family: 'Fredoka One', cursive;
            color: #4A6A4A;
        }
        .journey-result .journey-best {
            font-size: 12px;
            color: #8A7A6A;
            margin-top: 6px;
        }
        .journey-result .journey-best.new-best {
            color: #DAA520;
            font-weight: bold;
        }
        .journey-encouragement {
            font-size: 13px;
            color: #5A4A3A;
            font-style: italic;
            margin-top: 8px;
        }
        @media (min-width: 768px) {
            .journey-result .journey-location { font-size: 24px; }
            .journey-result .journey-label { font-size: 14px; }
            .journey-result .journey-best { font-size: 14px; }
            .journey-encouragement { font-size: 15px; }
        }

        /* Game-over polish - Part E: Tap overlay to restart hint */
        #gameOverOverlay {
            cursor: pointer;
        }
        #gameOverOverlay .overlay-content {
            cursor: default;
        }
               /* v1.1: keep game-over modal truly centered; hint shouldn't affect flex centering */
        .tap-hint {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: max(12px, env(safe-area-inset-bottom));
            font-size: 11px;
            color: rgba(255,255,255,0.6);
            text-align: center;
            pointer-events: none;
            margin-top: 0; /* no longer in normal flow */
        }


        /* Game-over polish - Part F: Disable screen shake in reduce-motion */
        body.reduce-motion .game-container.shake {
            animation: none !important;
        }
        /* Mobile UX: gameplay band lift is now handled in JS via getMobileBaselineOffset() */
/* iOS Chrome flash hardening (ship build)
   Visual-only overrides to avoid WebKit compositor flicker */
@supports (-webkit-touch-callout: none) {

	/* Disable filters on moving elements */
	.tater { filter: none !important; }
	.sprite { filter: none !important; }
	.life-bone.lost { filter: none !important; }

	/* Disable full-screen opacity animations on iOS */
	.game-container::after,
	.vignette-overlay,
	.damage-flash,
	.heal-flash,
	.overlay,
	#gameOverOverlay {
		transition: none !important;
		animation: none !important;
	}

	/* iOS stability: avoid forcing the whole scene onto a single composited layer */
	.game-container {
		contain: none !important;
		-webkit-transform: none !important;
		transform: none !important;
		-webkit-backface-visibility: visible !important;
		backface-visibility: visible !important;
		will-change: auto !important;
	}

	/* iOS stability test: remove always-present dim pseudo-layer */
	.game-container::after {
		display: none !important;
	}

	/* iOS flash reduction: de-promote hidden full-screen fixed overlays */
	.overlay,
	.vignette-overlay,
	.damage-flash,
	.heal-flash,
	#gameOverOverlay {
		-webkit-transform: none !important;
		transform: none !important;
		will-change: auto !important;
	}

	/* iOS flash reduction: de-promote huge continuously-animated parallax layers */
	.clouds,
	.landmarks-far,
	.landmarks-mid,
	.park-elements,
	.path {
		will-change: auto !important;
		-webkit-backface-visibility: visible !important;
		backface-visibility: visible !important;
	}
	/* iOS flash reduction: use 2D transforms for parallax animations (avoid 3D compositor resets) */
	@keyframes scroll-clouds-ios {
		0% { transform: translateX(0); }
		100% { transform: translateX(-66.6667%); }
	}
	@keyframes scroll-far-ios {
		0% { transform: translateX(0); }
		100% { transform: translateX(-66.6667%); }
	}
	@keyframes scroll-mid-ios {
		0% { transform: translateX(0); }
		100% { transform: translateX(-66.6667%); }
	}
	@keyframes scroll-park-ios {
		0% { transform: translateX(0); }
		100% { transform: translateX(-66.6667%); }
	}
	@keyframes scroll-path-ios {
		0% { transform: translateX(0); }
		100% { transform: translateX(-66.6667%); }
	}

	/* iOS ship fix: disable road animation to eliminate remaining flash */
	.path {
		animation: none !important;
	}

    	/* iOS flash reduction: remove full-screen layers from compositor when hidden */
	.overlay:not(.show) {
		display: none !important;
	}
	.overlay.show {
		display: flex !important;
	}

	.vignette-overlay:not(.show),
	.damage-flash:not(.show),
	.heal-flash:not(.show) {
		display: none !important;
	}
	.vignette-overlay.show,
	.damage-flash.show,
	.heal-flash.show {
		display: block !important;
	}

	/* iOS ship fix: lock stable parallax animation sub-properties (no isolate harness) */
	.clouds {
		animation-name: scroll-clouds-ios !important;
		animation-duration: calc(120s / var(--ambient-motion-factor, 1)) !important;
		animation-timing-function: linear !important;
		animation-iteration-count: infinite !important;
		animation-play-state: running !important;
	}

	.landmarks-far {
		animation-name: scroll-far-ios !important;
		animation-duration: calc(180s / var(--ambient-motion-factor, 1)) !important;
		animation-timing-function: linear !important;
		animation-iteration-count: infinite !important;
		animation-play-state: running !important;
	}

	.landmarks-mid {
		animation-name: scroll-mid-ios !important;
		animation-duration: calc(140s / var(--ambient-motion-factor, 1)) !important;
		animation-timing-function: linear !important;
		animation-iteration-count: infinite !important;
		animation-play-state: running !important;
	}

	.park-elements {
		animation-name: scroll-park-ios !important;
		animation-duration: calc(90s / var(--ambient-motion-factor, 1)) !important;
		animation-timing-function: linear !important;
		animation-iteration-count: infinite !important;
		animation-play-state: running !important;
	}

		/* iOS ship fix: disable road animation to eliminate remaining flash */
	.path {
		animation: none !important;
	}
    	/* iOS hop fix: keep sprite idle animations on translate3d to avoid 2D/3D transform snapping */
	@keyframes balloon-float {
		0%, 100% { transform: translate3d(0, 0, 0) rotate(-2deg); }
		25% { transform: translate3d(0, -3px, 0) rotate(0deg); }
		50% { transform: translate3d(0, -1px, 0) rotate(2deg); }
		75% { transform: translate3d(0, -4px, 0) rotate(0deg); }
	}

	@keyframes pigeon-bob {
		0%, 100% { transform: translate3d(0, 0, 0) scaleY(1); }
		50% { transform: translate3d(0, -2px, 0) scaleY(0.95); }
	}

	@keyframes thunder-jitter {
		0%, 100% { transform: translate3d(0, 0, 0); }
		25% { transform: translate3d(0, -1px, 0); }
		75% { transform: translate3d(0, 1px, 0); }
	}

	@keyframes vacuum-shake {
		0%, 100% { transform: translate3d(0, 0, 0); }
		50% { transform: translate3d(0, -1px, 0); }
	}

	@keyframes cat-prowl {
		0%, 100% { transform: translate3d(0, 0, 0); }
		50% { transform: translate3d(0, -1px, 0); }
	}

	}

/* Windows Chrome perf hardening
   Disable paint-heavy filters on moving sprites */
.windows-platform .sprite { filter: none !important; }
.windows-platform .tater { filter: none !important; }

/* Windows low-paint mode (auto-enabled when FPS drops below 50)
   Additional paint reductions beyond windows-platform baseline */
.low-paint .sprite,
.low-paint .tater,
.low-paint .obstacle,
.low-paint .powerup {
    filter: none !important;
    box-shadow: none !important;
    text-shadow: none !important;
}
.low-paint .sprite::before,
.low-paint .sprite::after,
.low-paint .obstacle::before,
.low-paint .obstacle::after {
    display: none !important;
}

    </style>
</head>
<body>
    <div class="game-container">
        <div class="sky"></div>
        <div class="clouds" id="clouds"></div>
        <div class="landmarks-far" id="landmarksFar"></div>
        <div class="atmospheric-haze"></div>
        <div class="landmarks-mid" id="landmarksMid"></div>
        <div class="park-elements" id="parkElements"></div>
        <div class="grass"></div>
        <div class="path"></div>
        <div class="obstacles" id="obstacles"></div>

        <div class="tater-container" id="taterContainer">
            <!-- Visual pass - Tater the Corgi with storybook outline filter -->
            <svg class="tater" id="tater" viewBox="0 0 130 95" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <!-- Visual pass - subtle outline filter for storybook look -->
                    <filter id="taterOutline" x="-5%" y="-5%" width="110%" height="110%">
                        <feMorphology in="SourceAlpha" operator="dilate" radius="0.8" result="outline"/>
                        <feFlood flood-color="#8B5A2B" flood-opacity="0.4"/>
                        <feComposite in2="outline" operator="in" result="outlineColor"/>
                        <feMerge>
                            <feMergeNode in="outlineColor"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                    <!-- Gradients for better shading -->
                    <linearGradient id="furGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" stop-color="#FFAA50"/>
                        <stop offset="50%" stop-color="#E8943C"/>
                        <stop offset="100%" stop-color="#D07828"/>
                    </linearGradient>
                    <linearGradient id="furHighlight" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" stop-color="#FFC870"/>
                        <stop offset="100%" stop-color="#F8A84C"/>
                    </linearGradient>
                    <linearGradient id="bellyGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" stop-color="#FFFFFF"/>
                        <stop offset="100%" stop-color="#FFF0E8"/>
                    </linearGradient>
                    <linearGradient id="noseGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" stop-color="#3A2A20"/>
                        <stop offset="100%" stop-color="#1A0A00"/>
                    </linearGradient>
                </defs>

                <!-- Visual pass - Tail with subtle outline -->
                <g class="tater-tail">
                    <ellipse cx="12" cy="35" rx="13" ry="10" fill="url(#furGradient)" stroke="#B07020" stroke-width="0.8"/>
                    <ellipse cx="14" cy="33" rx="9" ry="6" fill="url(#furHighlight)"/>
                    <ellipse cx="10" cy="32" rx="4" ry="3" fill="#FFC870" opacity="0.6"/>
                </g>

                <!-- Back legs with better shading -->
                <g class="tater-back-legs">
                    <ellipse cx="30" cy="65" rx="10" ry="15" fill="url(#furGradient)">
                        <animate attributeName="ry" values="15;12;15" dur="0.2s" repeatCount="indefinite"/>
                    </ellipse>
                    <ellipse cx="32" cy="63" rx="6" ry="10" fill="url(#furHighlight)" opacity="0.7">
                        <animate attributeName="ry" values="10;8;10" dur="0.2s" repeatCount="indefinite"/>
                    </ellipse>
                    <ellipse cx="30" cy="78" rx="9" ry="5" fill="url(#bellyGradient)"/>
                    <path d="M 23 78 Q 30 82 37 78" stroke="#E8D0C0" stroke-width="1" fill="none" opacity="0.5"/>
                </g>

                <!-- Visual pass - Body with subtle outline -->
                <ellipse cx="55" cy="46" rx="36" ry="23" fill="url(#furGradient)" stroke="#A06018" stroke-width="1"/>
                <ellipse cx="58" cy="43" rx="28" ry="17" fill="url(#furHighlight)"/>
                <ellipse cx="50" cy="40" rx="12" ry="8" fill="#FFC870" opacity="0.4"/>

                <!-- White chest/belly with soft gradient -->
                <ellipse cx="78" cy="53" rx="23" ry="18" fill="url(#bellyGradient)"/>
                <ellipse cx="80" cy="50" rx="17" ry="13" fill="#FFFFFF"/>
                <ellipse cx="82" cy="48" rx="10" ry="8" fill="#FFFFFF" opacity="0.8"/>

                <!-- Front legs with shading -->
                <g class="tater-front-legs">
                    <ellipse cx="88" cy="64" rx="9" ry="16" fill="url(#bellyGradient)">
                        <animate attributeName="ry" values="16;13;16" dur="0.2s" repeatCount="indefinite" begin="0.1s"/>
                    </ellipse>
                    <ellipse cx="90" cy="62" rx="5" ry="10" fill="#FFFFFF" opacity="0.6">
                        <animate attributeName="ry" values="10;8;10" dur="0.2s" repeatCount="indefinite" begin="0.1s"/>
                    </ellipse>
                    <ellipse cx="88" cy="78" rx="9" ry="5" fill="url(#bellyGradient)"/>
                    <path d="M 81 78 Q 88 82 95 78" stroke="#E8D0C0" stroke-width="1" fill="none" opacity="0.5"/>
                </g>

                <!-- Neck fluff -->
                <ellipse cx="95" cy="42" rx="15" ry="14" fill="url(#bellyGradient)"/>
                <ellipse cx="97" cy="40" rx="10" ry="9" fill="#FFFFFF" opacity="0.7"/>

                <!-- Visual pass - Head with subtle outline -->
                <ellipse cx="105" cy="30" rx="21" ry="19" fill="url(#furGradient)" stroke="#A06018" stroke-width="0.8"/>
                <ellipse cx="107" cy="28" rx="15" ry="13" fill="url(#furHighlight)"/>
                <ellipse cx="104" cy="25" rx="8" ry="6" fill="#FFC870" opacity="0.5"/>

                <!-- Visual pass - Left ear with subtle outline -->
                <g class="tater-ear-left">
                    <ellipse cx="92" cy="14" rx="8" ry="13" fill="url(#furGradient)" transform="rotate(-15 92 14)" stroke="#A06018" stroke-width="0.6"/>
                    <ellipse cx="93" cy="16" rx="5" ry="9" fill="#FFCB8E" transform="rotate(-15 93 16)"/>
                    <ellipse cx="93" cy="18" rx="3" ry="5" fill="#FFD8A8" transform="rotate(-15 93 18)" opacity="0.7"/>
                </g>

                <!-- Visual pass - Right ear with subtle outline -->
                <g class="tater-ear-right">
                    <ellipse cx="115" cy="12" rx="8" ry="13" fill="url(#furGradient)" transform="rotate(15 115 12)" stroke="#A06018" stroke-width="0.6"/>
                    <ellipse cx="114" cy="14" rx="5" ry="9" fill="#FFCB8E" transform="rotate(15 114 14)"/>
                    <ellipse cx="114" cy="16" rx="3" ry="5" fill="#FFD8A8" transform="rotate(15 114 16)" opacity="0.7"/>
                </g>

                <!-- Face marking (white blaze) -->
                <ellipse cx="116" cy="34" rx="12" ry="13" fill="url(#bellyGradient)"/>
                <ellipse cx="117" cy="32" rx="8" ry="9" fill="#FFFFFF" opacity="0.8"/>

                <!-- Snout with better definition -->
                <ellipse cx="122" cy="36" rx="10" ry="9" fill="url(#bellyGradient)"/>
                <ellipse cx="124" cy="35" rx="7" ry="6" fill="#FFFFFF"/>
                <ellipse cx="125" cy="34" rx="4" ry="3" fill="#FFFFFF" opacity="0.8"/>

                <!-- Eyes with more expression -->
                <ellipse cx="102" cy="27" rx="6" ry="7" fill="#FFFFFF"/>
                <ellipse cx="115" cy="27" rx="6" ry="7" fill="#FFFFFF"/>
                <!-- Eye outline for definition -->
                <ellipse cx="102" cy="27" rx="6" ry="7" fill="none" stroke="#C08040" stroke-width="0.5" opacity="0.5"/>
                <ellipse cx="115" cy="27" rx="6" ry="7" fill="none" stroke="#C08040" stroke-width="0.5" opacity="0.5"/>
                <!-- Pupils with shine -->
                <circle cx="104" cy="28" r="4" fill="#2A1810"/>
                <circle cx="117" cy="28" r="4" fill="#2A1810"/>
                <circle cx="105" cy="27" r="1.5" fill="#4A3020"/>
                <circle cx="118" cy="27" r="1.5" fill="#4A3020"/>
                <!-- Eye highlights -->
                <circle cx="102" cy="25" r="2" fill="#FFFFFF"/>
                <circle cx="115" cy="25" r="2" fill="#FFFFFF"/>
                <circle cx="106" cy="29" r="0.8" fill="#FFFFFF" opacity="0.6"/>
                <circle cx="119" cy="29" r="0.8" fill="#FFFFFF" opacity="0.6"/>
                <!-- Eyelids for blink animation -->
                <ellipse class="tater-eyelid-left" cx="102" cy="27" rx="6" ry="7" fill="#E8943C" transform-origin="102px 27px"/>
                <ellipse class="tater-eyelid-right" cx="115" cy="27" rx="6" ry="7" fill="#E8943C" transform-origin="115px 27px"/>

                <!-- Eyebrows with better expression (happy/alert) -->
                <path d="M 97 21 Q 102 19 107 21" stroke="#C07030" stroke-width="2" fill="none" stroke-linecap="round"/>
                <path d="M 110 21 Q 115 19 120 21" stroke="#C07030" stroke-width="2" fill="none" stroke-linecap="round"/>

                <!-- Nose with glossy highlight -->
                <ellipse cx="130" cy="36" rx="4.5" ry="4" fill="url(#noseGradient)"/>
                <ellipse cx="129" cy="34" rx="2" ry="1.2" fill="#5A4A40" opacity="0.6"/>
                <ellipse cx="131" cy="35" rx="1" ry="0.6" fill="#6A5A50" opacity="0.4"/>

                <!-- Mouth with smile -->
                <path d="M 128 40 Q 124 45 118 43 Q 114 41 112 42" stroke="#2A1810" stroke-width="1.8" fill="none" stroke-linecap="round"/>

                <!-- Tongue (animated group) -->
                <g class="tater-tongue">
                    <ellipse cx="120" cy="49" rx="5" ry="8" fill="#FF7080"/>
                    <ellipse cx="120" cy="47" rx="3.5" ry="5" fill="#FF9098"/>
                    <ellipse cx="120" cy="45" rx="2" ry="3" fill="#FFA8B0" opacity="0.8"/>
                    <line x1="120" y1="44" x2="120" y2="54" stroke="#E06070" stroke-width="1.2" stroke-linecap="round"/>
                </g>

                <!-- Cheek blush -->
                <ellipse cx="126" cy="42" rx="3.5" ry="2" fill="#FFB0B0" opacity="0.5"/>
                <ellipse cx="97" cy="32" rx="3" ry="2" fill="#FFB0B0" opacity="0.4"/>

                <!-- Whisker dots -->
                <circle cx="127" cy="39" r="0.8" fill="#C08050" opacity="0.6"/>
                <circle cx="129" cy="41" r="0.8" fill="#C08050" opacity="0.6"/>
                <circle cx="126" cy="43" r="0.8" fill="#C08050" opacity="0.6"/>
            </svg>
            <div class="shadow" id="shadow"></div>
        </div>
    </div>

    <!-- Mobile UI - restructured header with mobile menu -->
    <div class="ui-top">
        <div class="lives-container" id="livesContainer"></div>
        <div class="controls-wrapper">
            <div class="controls">
                <button class="btn" id="muteBtn"><span class="btn-icon">ðŸ”Š</span><span class="btn-label">ðŸ”Š</span></button>
                <button class="btn" id="pauseBtn"><span class="btn-icon">â¸</span><span class="btn-label">Pause</span></button>
                <!-- Mobile UI - desktop-only reset button (inside controls row) -->
                <button class="btn" id="resetBtn"><span class="btn-label">Reset</span></button>
                <!-- Mobile UI - more menu button (mobile only) -->
                <button class="btn mobile-more-btn" id="moreBtn"><span class="btn-icon">â‹¯</span></button>
            </div>
            <!-- Mobile UI - dropdown menu for secondary controls -->
            <div class="mobile-menu" id="mobileMenu">
                <button class="btn" id="resetBtnMobile"><span class="btn-icon">â†»</span><span class="btn-label">Reset</span></button>
                <!-- Accessibility - Settings button in mobile menu -->
                <button class="btn settings-btn" id="settingsBtnMobile"><span class="btn-icon">âš™</span><span class="btn-label">Settings</span></button>
            </div>
        </div>
    </div>

    <div class="game-title">Tater's Adventure Through London</div>
    <div class="score-display">Score: <span id="score">0</span></div>
    <!-- Priority 3: Developer debug HUD (toggle with D key) -->
    <div class="debug-hud" id="debugHud"></div>
    <!-- Journey framing - Location display -->
    <div class="location-display" id="locationDisplay">
        <span class="location-name" id="locationName">Lost in Hyde Park</span>
        <span class="location-progress" id="locationProgress">Keeping close.</span>
    </div>
    <!-- Journey framing - Milestone banner (non-blocking) -->
    <!-- Journey framing v2 - Calm milestone banner -->
    <div class="milestone-banner" id="milestoneBanner">
        <div class="milestone-label">A little closer.</div>
        <div class="milestone-name" id="milestoneName">Paddington</div>
    </div>
    <div class="jump-indicator" id="jumpIndicator"></div>
    <!-- Onboarding - hint bar: empty by default, content set dynamically -->
    <div class="hint hidden" id="hintBar"></div>
    <!-- Visual hierarchy & pacing - Part B: Pre-run start prompt -->
    <div class="start-prompt" id="startPrompt">Hold to start</div>

    <div class="damage-flash" id="damageFlash"></div>
    <div class="heal-flash" id="healFlash"></div>
    <!-- Game-over polish - Part B: Vignette overlay for cinematic effect -->
    <div class="vignette-overlay" id="vignetteOverlay"></div>

    <div class="overlay" id="pauseOverlay">
        <div class="overlay-content">
            <div class="overlay-title">Paused</div>
            <button class="overlay-btn" id="resumeBtn">Resume</button>
        </div>
    </div>

    <!-- Game-over polish - Part D: Enhanced game over overlay -->
    <!-- Journey framing - Updated with journey-focused messaging -->
    <!-- CHANGE (story): home clarity â€” title updates when player reached final stage -->
    <div class="overlay" id="gameOverOverlay">
        <div class="overlay-content">
            <div class="overlay-title" id="gameOverTitle">Oh no!</div>
            <div class="game-over-message" id="gameOverMessage">Tater got too scared!</div>
            <!-- Journey framing - Journey result display -->
            <div class="journey-result">
                <div class="journey-label">Tater made it to:</div>
                <div class="journey-location" id="journeyLocation">Hyde Park</div>
                <div class="journey-best" id="journeyBest">Best: Hyde Park</div>
            </div>
            <div class="final-score-display" id="finalScore">0</div>
            <div class="journey-encouragement" id="journeyEncouragement">He's still trying to get homeâ€”let's go again!</div>
            <button class="overlay-btn" id="restartBtn">Try Again</button>
        </div>
        <!-- Game-over polish - Part E: Tap hint -->
        <div class="tap-hint">Tap anywhere to restart</div>
    </div>

    <!-- Step 4 tutorial - first-run tutorial overlay -->
    <div class="overlay" id="tutorialOverlay">
        <div class="overlay-content">
            <div class="overlay-title">How to Play</div>
            <div class="tutorial-tips">
                <div class="tutorial-tip">
                    <span class="tutorial-tip-icon">ðŸ‘†</span>
                    <span>Tap to jump, hold longer for higher jumps</span>
                </div>
                <div class="tutorial-tip">
                    <span class="tutorial-tip-icon">ðŸ¦´</span>
                    <span>Collect bones to restore health</span>
                </div>
                <div class="tutorial-tip">
                    <span class="tutorial-tip-icon">ðŸ˜±</span>
                    <span>Avoid scary things - Tater is easily frightened!</span>
                </div>
            </div>
            <button class="overlay-btn" id="tutorialBtn">Got it!</button>
        </div>
    </div>

    <!-- Share polish - About modal -->
    <div class="overlay" id="aboutOverlay">
        <div class="overlay-content about-content">
            <div class="overlay-title">About</div>
            <div class="about-description">
                Help Tater the corgi run through London, jumping over scary things and collecting bones!
            </div>
            <div class="about-credits">
                <div><strong>Made by Patric</strong></div>
                <div class="about-dedication">for Tater ðŸ•</div>
            </div>
            <button class="overlay-btn" id="aboutCloseBtn">Close</button>
        </div>
    </div>

    <!-- Accessibility - Settings modal -->
    <div class="overlay" id="settingsOverlay">
        <div class="overlay-content settings-content">
            <div class="overlay-title">Settings</div>
            <div class="settings-section">
                <div class="settings-toggle">
                    <div>
                        <div class="settings-toggle-label">Reduce Motion</div>
                        <div class="settings-toggle-desc">Slow/disable non-essential animations</div>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="reduceMotionToggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="settings-toggle">
                    <div>
                        <div class="settings-toggle-label">High Contrast</div>
                        <div class="settings-toggle-desc">Improve UI readability</div>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="highContrastToggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            <div class="settings-keyboard">
                <div class="settings-keyboard-title">Keyboard Controls</div>
                <div class="settings-keyboard-item"><kbd>Space</kbd> / <kbd>Enter</kbd> - Hold to jump</div>
                <div class="settings-keyboard-item"><kbd>P</kbd> - Pause</div>
                <div class="settings-keyboard-item"><kbd>R</kbd> - Restart</div>
                <div class="settings-keyboard-item"><kbd>D</kbd> - Debug</div>
            </div>
            <button class="overlay-btn secondary" id="helpBtn">How to Play</button>
            <button class="overlay-btn" id="settingsCloseBtn">Close</button>
        </div>
    </div>

    <!-- Share polish - About button -->
    <button class="about-btn" id="aboutBtn" aria-label="About">i</button>

    <!-- Share polish - Version string -->
    <div class="version-string" id="versionString"></div>

    <script>
        // Debug - lightweight error logging
        window.addEventListener('error', e => {
            console.error('[ERROR]', e.message, 'line:', e.lineno);
        });

        // Priority 1: Single source of truth for version
        const GAME_VERSION = 'v1.1';

        // Debug - set to true to log when pre-run transitions to running
        const DEBUG_START = false;

        // Priority 3: Debug HUD state (toggle with D key)
        let debugHudVisible = false;
        let boneBiasLastApplied = false;
        let lastDebugHudUpdate = 0;

        // Priority 3: Throttled debug HUD update (max 10Hz to avoid perf issues)
        function updateDebugHud(now) {
            if (!debugHudVisible) return;
            if (now - lastDebugHudUpdate < 100) return; // Throttle to 10 FPS
            lastDebugHudUpdate = now;

            const tier = typeof getDifficultyTier === 'function' ? getDifficultyTier(score) : '?';
            const mult = getSpawnIntervalMultiplier(score);
            const spawnDelta = now - lastSpawnTime;
            const effInterval = baseSpawnInterval * mult;

            document.getElementById('debugHud').innerHTML =
                `score:${score} tier:${tier}<br>` +
                `spd:${gameSpeed.toFixed(2)} obs:${obstacles.length} pwr:${powerups.length}<br>` +
                `spawnÎ”:${spawnDelta.toFixed(0)}ms eff:${effInterval.toFixed(0)}ms<br>` +
                `mult:${mult.toFixed(2)} bias:${boneBiasLastApplied ? 'âœ“' : '-'}`;

            // Reset bias flag after displaying
            boneBiasLastApplied = false;
        }

        // Ship safety - localStorage helpers (graceful fallback if storage unavailable)
        function safeGet(key) {
            try { return localStorage.getItem(key); }
            catch { return null; }
        }
        function safeSet(key, value) {
            try { localStorage.setItem(key, String(value)); }
            catch { /* storage unavailable, continue silently */ }
        }

        // Convenience reference for body
        const body = document.body;

        const tater = document.getElementById('tater');
        const taterContainer = document.getElementById('taterContainer');
        const shadow = document.getElementById('shadow');
        const obstaclesContainer = document.getElementById('obstacles');
        const scoreDisplay = document.getElementById('score');
        const livesContainer = document.getElementById('livesContainer');
        const jumpIndicator = document.getElementById('jumpIndicator');
        const damageFlash = document.getElementById('damageFlash');
        const healFlash = document.getElementById('healFlash');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const finalScoreDisplay = document.getElementById('finalScore');
        const gameContainer = document.querySelector('.game-container');
        // Windows platform detection for perf optimizations (robust: platform + userAgent)
        const IS_WINDOWS = /Win/.test(navigator.platform) || /Windows/.test(navigator.userAgent);
        if (IS_WINDOWS) gameContainer.classList.add('windows-platform');
        const muteBtn = document.getElementById('muteBtn');
        const tutorialOverlay = document.getElementById('tutorialOverlay'); // Step 4 tutorial
        const hintBar = document.getElementById('hintBar'); // UI polish - hint bar reference
        const aboutOverlay = document.getElementById('aboutOverlay'); // Share polish
        const startPrompt = document.getElementById('startPrompt'); // Visual hierarchy & pacing - pre-run prompt
        // Game-over polish - element references
        const vignetteOverlay = document.getElementById('vignetteOverlay');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const gameOverTitle = document.getElementById('gameOverTitle'); // CHANGE (story): home clarity
        // Journey framing - Element references
        const locationDisplay = document.getElementById('locationDisplay');
        const locationName = document.getElementById('locationName');
        const locationProgress = document.getElementById('locationProgress');
        const milestoneBanner = document.getElementById('milestoneBanner');
        const milestoneName = document.getElementById('milestoneName');
        const journeyLocation = document.getElementById('journeyLocation');
        const journeyBest = document.getElementById('journeyBest');
        const journeyEncouragement = document.getElementById('journeyEncouragement');

        // Share polish - About modal functions
        // CHANGE (cleanup): overlay pause â€” consistent pause/resume for About and Settings
        let wasPausedBeforeOverlay = false;

        function showAbout() {
            // Save current pause state before opening overlay
            wasPausedBeforeOverlay = isPaused;
            // Pause game safely while overlay is open
            if (!isGameOver && !preRunState) {
                isPaused = true;
                pauseAnimations(true);
                body.classList.remove('playing');
            }
            startPrompt.classList.remove('show');
            aboutOverlay.classList.add('show');
        }
        function hideAbout() {
            aboutOverlay.classList.remove('show');
            // Resume only if game was not paused before and is in playable state
            if (!wasPausedBeforeOverlay && !isGameOver && !tutorialActive && !preRunState) {
                isPaused = false;
                pauseAnimations(false);
                body.classList.add('playing');
            }
        }

        // Accessibility - Settings modal functions
        const settingsOverlay = document.getElementById('settingsOverlay');
        const reduceMotionToggle = document.getElementById('reduceMotionToggle');
        const highContrastToggle = document.getElementById('highContrastToggle');

        function showSettings() {
            // Save current pause state before opening overlay
            wasPausedBeforeOverlay = isPaused;
            // Pause game safely while overlay is open
            if (!isGameOver && !preRunState) {
                isPaused = true;
                pauseAnimations(true);
                body.classList.remove('playing');
            }
            startPrompt.classList.remove('show');
            settingsOverlay.classList.add('show');
        }
        function hideSettings() {
            settingsOverlay.classList.remove('show');
            // Resume only if game was not paused before and is in playable state
            if (!wasPausedBeforeOverlay && !isGameOver && !tutorialActive && !preRunState) {
                isPaused = false;
                pauseAnimations(false);
                body.classList.add('playing');
            }
        }

        // Accessibility - Load settings from localStorage, inferring from OS if not set
        function loadAccessibilitySettings() {
            // Check if keys exist in localStorage
            const storedReduceMotion = safeGet('taterReduceMotion');
            const storedHighContrast = safeGet('taterHighContrast');

            // Infer from OS settings if localStorage key is missing (null)
            let reduceMotion, highContrast;

            if (storedReduceMotion === null) {
                // Infer from OS: prefers-reduced-motion: reduce
                reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                safeSet('taterReduceMotion', reduceMotion.toString());
            } else {
                reduceMotion = storedReduceMotion === 'true';
            }

            if (storedHighContrast === null) {
                // Infer from OS: prefers-contrast: more OR forced-colors: active
                highContrast = window.matchMedia('(prefers-contrast: more)').matches ||
                               window.matchMedia('(forced-colors: active)').matches;
                safeSet('taterHighContrast', highContrast.toString());
            } else {
                highContrast = storedHighContrast === 'true';
            }

            reduceMotionToggle.checked = reduceMotion;
            highContrastToggle.checked = highContrast;

            body.classList.toggle('reduce-motion', reduceMotion);
            body.classList.toggle('high-contrast', highContrast);
        }

        // Accessibility - Helper to refresh sprite animations when Reduce Motion toggles mid-run
        function refreshSpriteAnimations() {
            // Force all sprites with idle classes to recompute their styles
            document.querySelectorAll('.sprite[class*="-idle"]').forEach(sprite => {
                // Get all idle classes on this sprite
                const idleClasses = Array.from(sprite.classList).filter(c => c.endsWith('-idle'));
                if (idleClasses.length > 0) {
                    // Remove and re-add to force CSS recomputation
                    idleClasses.forEach(c => sprite.classList.remove(c));
                    // Use requestAnimationFrame to ensure the removal is processed
                    requestAnimationFrame(() => {
                        idleClasses.forEach(c => sprite.classList.add(c));
                    });
                }
            });
        }

        // Accessibility - Toggle handlers
        reduceMotionToggle.addEventListener('change', () => {
            const enabled = reduceMotionToggle.checked;
            safeSet('taterReduceMotion', enabled);
            body.classList.toggle('reduce-motion', enabled);
            // Refresh existing sprite animations to apply/remove reduce-motion styles
            refreshSpriteAnimations();
        });

        highContrastToggle.addEventListener('change', () => {
            const enabled = highContrastToggle.checked;
            safeSet('taterHighContrast', enabled);
            body.classList.toggle('high-contrast', enabled);
        });

        // Accessibility - Load settings on startup
        loadAccessibilitySettings();

        // Step 4 tutorial - check if tutorial has been seen
        let tutorialActive = safeGet('taterTutorialSeen') !== 'true';

        // Onboarding - toast system state
        let toastTimeout = null;
        let toastShownJump = safeGet('taterToastJump') === 'true';
        let toastShownBone = safeGet('taterToastBone') === 'true';

        // Onboarding - check if any overlay is currently visible
        function isAnyOverlayVisible() {
            return isPaused || isGameOver || tutorialActive ||
                   aboutOverlay.classList.contains('show') ||
                   settingsOverlay.classList.contains('show');
        }

        // Onboarding - show a temporary toast message using the hint bar
        function showToast(message, duration = 2000) {
            // Don't show toasts during overlays or pre-run
            if (isAnyOverlayVisible() || preRunState) return;
            // Clear any existing toast
            if (toastTimeout) {
                clearTimeout(toastTimeout);
                toastTimeout = null;
            }
            // Update and show the hint bar as a toast
            hintBar.textContent = message;
            hintBar.classList.remove('hidden', 'toast-out');
            hintBar.classList.add('toast');
            // Schedule fade out
            toastTimeout = setTimeout(() => {
                hintBar.classList.remove('toast');
                hintBar.classList.add('toast-out');
                // Fully hide after animation
                setTimeout(() => {
                    hintBar.classList.add('hidden');
                    hintBar.classList.remove('toast-out');
                }, 400);
                toastTimeout = null;
            }, duration);
        }
        let preRunState = true; // Game starts in pre-run state, waiting for first input

        // CHANGE (ambient-ramp): Gentle ramp from 0.55 to 1.0 over time or until first milestone
        const AMBIENT_RAMP_START = 0.55;
        const AMBIENT_RAMP_END = 1.0;
        const AMBIENT_RAMP_DURATION = 15000; // 15 seconds (within 12-18s range)
        const AMBIENT_RAMP_MILESTONE = 200;  // First journey milestone threshold

        // CHANGE (ambient): ambientMotionFactor controls background motion speed
        // 1.0 = normal speed, < 1.0 = slower (e.g., 0.55 for calm pre-run)
        let ambientMotionFactor = 1;
        function setAmbientMotionFactor(factor) {
            // iOS hardening: prevent invalid CSS var values that can cause animation duration spikes
            let f = Number(factor);
            if (!Number.isFinite(f)) f = AMBIENT_RAMP_START;
            // Clamp to a sane range (keep existing behavior but avoid spikes)
            f = Math.max(0.45, Math.min(1.05, f));
            ambientMotionFactor = f;
            document.documentElement.style.setProperty('--ambient-motion-factor', f.toFixed(3));
        }

        let ambientRampActive = false;
        let ambientRampStartTime = 0;
        let ambientRampPausedElapsed = 0; // Elapsed time saved when paused

        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }

        function startAmbientRamp() {
            setAmbientMotionFactor(AMBIENT_RAMP_START);
            ambientRampActive = true;
            ambientRampStartTime = performance.now();
            ambientRampPausedElapsed = 0;
        }

        function updateAmbientRamp(currentScore) {
            if (!ambientRampActive) return;
            // End ramp early if player crosses first milestone
            if (currentScore >= AMBIENT_RAMP_MILESTONE) {
                completeAmbientRamp();
                return;
            }
            // Calculate progress based on elapsed time
            const elapsed = performance.now() - ambientRampStartTime;
            const progress = Math.min(elapsed / AMBIENT_RAMP_DURATION, 1);
            const easedProgress = easeOutCubic(progress);
            const newFactor = AMBIENT_RAMP_START + (AMBIENT_RAMP_END - AMBIENT_RAMP_START) * easedProgress;
            setAmbientMotionFactor(newFactor);
            // Complete ramp when time is up
            if (progress >= 1) {
                completeAmbientRamp();
            }
        }

        function completeAmbientRamp() {
            ambientRampActive = false;
            setAmbientMotionFactor(AMBIENT_RAMP_END);
        }

        // resetAmbientRamp: MUST set AMBIENT_RAMP_START (not END) for pre-run calm state.
        // This ensures the background is slow during pre-run, matching the speed when gameplay
        // begins via startAmbientRamp(). Setting END here would cause a "sprint" visual glitch.
        function resetAmbientRamp() {
            ambientRampActive = false;
            ambientRampPausedElapsed = 0;
            setAmbientMotionFactor(AMBIENT_RAMP_START);
        }

        function pauseAmbientRamp() {
            if (ambientRampActive) {
                ambientRampPausedElapsed = performance.now() - ambientRampStartTime;
            }
        }

        function resumeAmbientRamp() {
            if (ambientRampActive) {
                ambientRampStartTime = performance.now() - ambientRampPausedElapsed;
            }
        }

        // CHANGE (high-speed-visual): Toggle body.high-speed class to dampen noisy idle animations
        // This is VISUAL ONLY - does not affect gameplay, collision, or scoring
        const HIGH_SPEED_THRESHOLD = 1000;
        function updateHighSpeedVisual(currentScore) {
            const reduceMotion = body.classList.contains('reduce-motion');
            const highSpeedVisual = currentScore >= HIGH_SPEED_THRESHOLD && !reduceMotion;
            body.classList.toggle('high-speed', highSpeedVisual);
        }

        function resetHighSpeedVisual() {
            body.classList.remove('high-speed');
        }

        // CHANGE (cleanup): Hint bar is now purely a toast surface
        // No pre-run hints; only showToast() can display messages
        function showPreRunHint() {
            // No-op: pre-run hints removed; hint bar is toast-only
        }

        // Onboarding - hide hint bar (used when entering gameplay or overlays)
        function hideHintBar() {
            hintBar.classList.add('hidden');
            hintBar.classList.remove('toast', 'toast-out');
            if (toastTimeout) {
                clearTimeout(toastTimeout);
                toastTimeout = null;
            }
        }

        // Hint bar starts hidden; only showToast() can make it visible
        hintBar.classList.add('hidden');

        // Step 3 sound - WebAudio system
        let audioCtx = null;
        let isMuted = safeGet('taterMuted') === 'true';
        // Mobile UI - initialize mute button with both icon and label spans
        const initMuteIcon = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
        muteBtn.innerHTML = `<span class="btn-icon">${initMuteIcon}</span><span class="btn-label">${initMuteIcon}</span>`;

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playJump() {
            if (!audioCtx || isMuted) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'sine';
            osc.frequency.setValueAtTime(280, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(520, audioCtx.currentTime + 0.08);
            gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.12);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.12);
        }

        function playLand() {
            if (!audioCtx || isMuted) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(180, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.08);
            gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }

        function playHit() {
            if (!audioCtx || isMuted) return;
            // Noise burst for impact
            const bufferSize = audioCtx.sampleRate * 0.15;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.15));
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 600;
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            noise.start();
        }

        function playHealOrCollect() {
            if (!audioCtx || isMuted) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'sine';
            // Pleasant ascending arpeggio feel
            osc.frequency.setValueAtTime(440, audioCtx.currentTime);
            osc.frequency.setValueAtTime(554, audioCtx.currentTime + 0.06);
            osc.frequency.setValueAtTime(659, audioCtx.currentTime + 0.12);
            gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime + 0.12);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.25);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.25);
        }

        function playGameOver() {
            if (!audioCtx || isMuted) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'sawtooth';
            // Descending sad tone
            osc.frequency.setValueAtTime(330, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(110, audioCtx.currentTime + 0.4);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.5);
        }

        function toggleMute() {
            isMuted = !isMuted;
            safeSet('taterMuted', isMuted);
            // Mobile UI - update both icon and label spans
            const icon = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
            muteBtn.innerHTML = `<span class="btn-icon">${icon}</span><span class="btn-label">${icon}</span>`;
        }

        // Step 3 juice - hit-stop variable (pause game updates briefly on damage)
        let hitStopUntil = 0;

        // Step 3 juice - floating text helper
        function showFloatText(text, x, y) {
            const el = document.createElement('div');
            el.className = 'float-text';
            el.textContent = text;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            gameContainer.appendChild(el);
            setTimeout(() => el.remove(), 600);
        }

        // CHANGE (difficulty): MAX_LIVES set to 3 (was 5)
        const MAX_LIVES = 3;

        let score = 0, lives = MAX_LIVES, isPaused = false, isGameOver = false, isJumping = false; // uses MAX_LIVES
        let isHolding = false, jumpPower = 0, velocity = 0, taterY = 0;
        let obstacles = [], powerups = [], lastSpawnTime = 0, lastPowerupTime = 0;
        let gameSpeed = 1, invulnerable = false;

        // Ship-hardening: game loop guard to prevent multiple loops running
        let gameLoopId = null;
        let gameLoopRunning = false;

        // Windows perf probe: ring buffer for frame durations, rect counter
        let perfFrameCount = 0;
        let perfRectReads = 0;
        const PERF_RING_SIZE = 180;
        const perfRing = new Float32Array(PERF_RING_SIZE);
        let perfRingIdx = 0;
        let perfLastFrameTime = 0;
        // Low-paint mode state (Windows only)
        let lowPaintBelowCount = 0;
        let lowPaintAboveCount = 0;

        // Windows perf probe: setInterval logger with low-paint auto-toggle
        if (IS_WINDOWS) {
            setInterval(() => {
                if (perfFrameCount === 0) return; // No frames yet
                const fps = perfFrameCount / 2; // 2-second interval
                // Compute avg and p95 from ring buffer
                const filled = Math.min(perfFrameCount, PERF_RING_SIZE);
                let sum = 0;
                const durations = [];
                for (let i = 0; i < filled; i++) {
                    const d = perfRing[i];
                    if (d > 0) { sum += d; durations.push(d); }
                }
                const avg = durations.length > 0 ? sum / durations.length : 0;
                durations.sort((a, b) => a - b);
                const p95 = durations.length > 0 ? durations[Math.floor(durations.length * 0.95)] : 0;
                const rectPerSec = perfRectReads / 2;
                console.log(`[win-perf] fps:${fps.toFixed(1)} avg:${avg.toFixed(1)}ms p95:${p95.toFixed(1)}ms dt:${dtMsLast.toFixed(1)} raw:${dtScaleRawLast.toFixed(2)} sm:${dtScaleSmoothed.toFixed(2)} rect/s:${rectPerSec.toFixed(0)} obs:${obstacles.length} pwr:${powerups.length}`);
                // Low-paint auto-toggle
                if (fps < 50) {
                    lowPaintBelowCount++;
                    lowPaintAboveCount = 0;
                    if (lowPaintBelowCount >= 3 && !document.body.classList.contains('low-paint')) {
                        document.body.classList.add('low-paint');
                        console.log('[win-perf] low-paint mode ENABLED');
                    }
                } else if (fps > 55) {
                    lowPaintAboveCount++;
                    lowPaintBelowCount = 0;
                    if (lowPaintAboveCount >= 3 && document.body.classList.contains('low-paint')) {
                        document.body.classList.remove('low-paint');
                        console.log('[win-perf] low-paint mode DISABLED');
                    }
                } else {
                    // FPS between 50-55: reset both counters
                    lowPaintBelowCount = 0;
                    lowPaintAboveCount = 0;
                }
                // Reset counters
                perfFrameCount = 0;
                perfRectReads = 0;
            }, 2000);
        }

        // Time-normalized horizontal movement (Windows Chrome low-FPS fix)
        let lastFrameTime = null;
        let dtScaleSmoothed = 1;
        let dtMsLast = 16.6667;
        let dtScaleRawLast = 1;

        // Mobile UX: Compute baseline offset to lift gameplay band on small screens
        // Desktop/tablet: 0 offset (baseY stays 9%). Mobile â‰¤520px: +9 offset (baseY becomes 18%)
        const DESKTOP_BASE_Y = 9;
        const MOBILE_BASELINE_OFFSET = 9;
        function getMobileBaselineOffset() {
            return window.innerWidth <= 520 ? MOBILE_BASELINE_OFFSET : 0;
        }
        function getBaseY() {
            return DESKTOP_BASE_Y + getMobileBaselineOffset();
        }
        let baseY = getBaseY(); // Computed on load, updated on resize
        function applyBaseYToTater(immediate = false) {
    baseY = getBaseY();

    // Ensure Tater is grounded visually
    taterY = 0;
    velocity = 0;
    isJumping = false;

    if (immediate) {
        // Prevent a visible â€œslideâ€ from CSS 9% â†’ JS baseY on initial paint
        const prev = taterContainer.style.transition;
        taterContainer.style.transition = 'none';
        taterContainer.style.bottom = baseY + '%';
        // force reflow so transition-none takes effect
        void taterContainer.offsetHeight;
        taterContainer.style.transition = prev || '';
    } else {
        taterContainer.style.bottom = baseY + '%';
    }

    shadow.style.transform = 'scale(1)';
    shadow.style.opacity = 0.3;
}

        // Visual hierarchy & pacing - Part B: Pre-run state

        // ========================================================================
        // JOURNEY v2 (single source of truth) â€” Priority 2
        // Quiet, earned progression. No countdown, no "Next: X in N".
        // 6 stages with atmospheric mood phrases. Milestone banners are brief.
        // ========================================================================

        // Journey framing v2 - London journey milestones (reduced to 6 for emotional weight)
        // Wider gaps between stages make each milestone feel earned
        // CHANGE (copy): Final stage is "Home" â€” soft destination, game stays endless
        const JOURNEY_STAGES = [
            { name: 'Lost in Hyde Park', threshold: 0, mood: 'Keeping close.' },
            { name: 'Paddington', threshold: 200, mood: 'Finding the way.' },
            { name: 'Soho', threshold: 450, mood: 'A familiar path.' },
            { name: "St Paul's", threshold: 800, mood: 'Not far now.' },
            { name: 'Tower Bridge', threshold: 1300, mood: 'Nearly safe.' },
            { name: 'Home', threshold: 1900, mood: 'He made it.' }
        ];

        // CHANGE (copy): Encouragements emphasize progress, not loss
        // Journey framing v2 - Gentle, reflective encouragements (no hype)
        const JOURNEY_ENCOURAGEMENTS = [
            "Each run brings Tater closer to home.",
            "He'll rest, then try again.",
            "A little further each time.",
            "The path home is still there.",
            "Some journeys take patience.",
            "He remembers the way now."
        ];

        // Journey framing - Track current stage index to detect milestone crossings
        let currentJourneyStageIndex = 0;
        let milestoneBannerTimeout = null;
        let milestonesShownThisRun = new Set(); // Gate: only show each milestone once per run

        // Journey framing - Get current journey stage based on score
        function getJourneyStage(currentScore) {
            let stage = JOURNEY_STAGES[0];
            let index = 0;
            for (let i = JOURNEY_STAGES.length - 1; i >= 0; i--) {
                if (currentScore >= JOURNEY_STAGES[i].threshold) {
                    stage = JOURNEY_STAGES[i];
                    index = i;
                    break;
                }
            }
            return { ...stage, index };
        }

        // OLD JOURNEY v1 (disabled) - getNextStage was used for "Next: X in N" countdown
        // Removed: function getNextStage(currentScore) { ... }

        // Journey framing - Get location name from a score value
        function getLocationFromScore(scoreValue) {
            return getJourneyStage(scoreValue).name;
        }

        // Journey framing v2 - Show milestone banner (non-blocking, brief, calm)
        function showMilestoneBanner(stageName) {
            // Clear any existing banner timeout
            if (milestoneBannerTimeout) {
                clearTimeout(milestoneBannerTimeout);
            }

            milestoneName.textContent = stageName;
            milestoneBanner.classList.add('show');

            // Priority 3: Emotional feedback - Tater settles briefly at milestone
            const reduceMotion = body.classList.contains('reduce-motion');
            const settleDuration = reduceMotion ? 500 : 800;
            applyTaterMood('settled', settleDuration);

            // Journey framing v2 - Reduced display time for subtlety (was 2000ms)
            milestoneBannerTimeout = setTimeout(() => {
                milestoneBanner.classList.remove('show');
                milestoneBannerTimeout = null;
            }, reduceMotion ? 1000 : 1400);
        }

        // Journey framing v2 - Update location display and check for milestones
        // Removed countdown "Next: X in N", replaced with quiet atmospheric phrases
        function updateJourneyDisplay(currentScore) {
            const stage = getJourneyStage(currentScore);

            // Update location name
            locationName.textContent = stage.name;

            // Journey framing v2 - Show quiet mood phrase instead of countdown
            // Each stage has its own atmospheric hint; no numbers, no urgency
            locationProgress.textContent = stage.mood || '';

            // Check for milestone crossing (only during active gameplay)
            if (stage.index > currentJourneyStageIndex && !isGameOver && !isPaused && !preRunState) {
                currentJourneyStageIndex = stage.index;
                // Gate: only show milestone banner once per run
                if (!milestonesShownThisRun.has(stage.index)) {
                    milestonesShownThisRun.add(stage.index);
                    showMilestoneBanner(stage.name);
                }
            }
        }

        // Journey framing - Reset journey state (called in resetGame)
        function resetJourneyState() {
            currentJourneyStageIndex = 0;
            milestonesShownThisRun.clear();
            if (milestoneBannerTimeout) {
                clearTimeout(milestoneBannerTimeout);
                milestoneBannerTimeout = null;
            }
            milestoneBanner.classList.remove('show');
            updateJourneyDisplay(0);
        }

        // ========================================================================
        // EMOTION v1 (single source of truth) â€” Priority 3
        // Fatigue ramp: WEARY (800) â†’ TIRED (1300). CSS-only, no physics impact.
        // Defeated + hopeful stacking handled via .tater.defeated.hopeful CSS.
        // Reset via resetTaterEmotionalState() clears all mood classes + timeouts.
        // ========================================================================

        // Tracks temporary emotional states applied to Tater
        let taterMoodTimeout = null;
        let taterHopefulTimeout = null;
        const WEARY_SCORE_THRESHOLD = 800;  // Score at which Tater shows subtle fatigue
        const TIRED_SCORE_THRESHOLD = 1300; // Score at which Tater shows tired-but-determined state
        // CHANGE (emotion): Single source of truth for all Tater mood classes
        // Used in resetTaterEmotionalState to ensure no mood leaks between runs
        const TATER_MOOD_CLASSES = ['settled', 'weary', 'tired', 'hopeful', 'defeated', 'hurt', 'healed'];

        // Priority 3: Emotional feedback - Apply temporary mood class to Tater
        // Ensures classes don't stack weirdly, clears prior timeouts
        function applyTaterMood(className, durationMs) {
            // Clear any existing mood timeout to prevent stacking
            if (taterMoodTimeout) {
                clearTimeout(taterMoodTimeout);
                taterMoodTimeout = null;
            }

            // Remove other temporary mood classes (but not persistent states like tired/defeated)
            tater.classList.remove('settled');

            // Apply the new mood
            tater.classList.add(className);

            // Schedule removal
            taterMoodTimeout = setTimeout(() => {
                tater.classList.remove(className);
                taterMoodTimeout = null;
            }, durationMs);
        }

        // Priority 3: Emotional feedback - Update fatigue state based on score
        // Called from score update locations; implements weary â†’ tired ramp
        function updateTaterTiredState(currentScore) {
            if (isGameOver) return;

            if (currentScore >= TIRED_SCORE_THRESHOLD) {
                // Late run: upgrade to tired, remove weary
                if (!tater.classList.contains('tired')) {
                    tater.classList.remove('weary');
                    tater.classList.add('tired');
                }
            } else if (currentScore >= WEARY_SCORE_THRESHOLD) {
                // Mid-late run: show weary (if not already tired)
                if (!tater.classList.contains('tired') && !tater.classList.contains('weary')) {
                    tater.classList.add('weary');
                }
            }
        }

        // Priority 3: Emotional feedback - Reset emotional states (called in resetGame)
        // CHANGE (emotion): clear all Tater mood classes on restart
        function resetTaterEmotionalState() {
            // Clear timeouts
            if (taterMoodTimeout) {
                clearTimeout(taterMoodTimeout);
                taterMoodTimeout = null;
            }
            if (taterHopefulTimeout) {
                clearTimeout(taterHopefulTimeout);
                taterHopefulTimeout = null;
            }
            // Remove all emotional/mood classes using single source of truth
            tater.classList.remove(...TATER_MOOD_CLASSES);
        }

        // Journey framing - Get random encouragement message
        function getJourneyEncouragement() {
            return JOURNEY_ENCOURAGEMENTS[Math.floor(Math.random() * JOURNEY_ENCOURAGEMENTS.length)];
        }

        // Journey framing v2 - Update game over display with gentle journey info
        // No emoji, no hype; reflective and warm tone
        function updateGameOverJourney(finalScore) {
            const currentLocation = getLocationFromScore(finalScore);
            const bestScore = parseInt(safeGet('taterBestScore') || '0', 10);
            const bestLocation = getLocationFromScore(bestScore);
            const isNewBest = finalScore > bestScore;

            journeyLocation.textContent = currentLocation;

            // Journey framing v2 - Gentle "furthest" messaging, no emoji
            if (isNewBest) {
                journeyBest.textContent = `A new furthest point: ${currentLocation}`;
                journeyBest.classList.add('new-best');
            } else {
                journeyBest.textContent = `Furthest so far: ${bestLocation}`;
                journeyBest.classList.remove('new-best');
            }

            journeyEncouragement.textContent = getJourneyEncouragement();
        }

        // Step 2.5 spawn pacing - spawn tracking variables
        let lastAirSpawnTime = 0;      // Tracks when last air hazard was spawned
        let lastTallSpawnTime = 0;     // Tracks when last tall/large obstacle was spawned
        let consecutiveSpawns = 0;     // Counts spawns since last breather
        let lastSpawnedType = null;    // Tracks last spawned obstacle type
        let lastSpawnedCategory = null; // Step 2.5 spawn pacing - track ground/air category
        let patternQueue = [];          // Step 2.5 spawn pacing - queued pattern obstacles
        let lastTallSpawnFrame = 0;     // Anti-cluster: tracks frame when tall hazard spawned

        // Gameplay polish - DEBUG flag for spawn decision logging
        const DEBUG = false;

        // Startup sanity check - confirms game initialized correctly
        if (DEBUG) {
            console.log('[INIT] Game initialized: preRunState=' + preRunState + ', tutorialActive=' + tutorialActive);
        }

        // Step 2.5 spawn pacing - categorization constants
        // ROSTER UPDATE: removed firework/hairdryer, added umbrella/frisbee, moved pigeon to air
        const AIR_HAZARDS = ['thunder', 'balloon', 'umbrella', 'frisbee', 'pigeon']; // groundY >= 12
        const GROUND_HAZARDS = ['mailman', 'vacuum', 'cat', 'cone', 'vet', 'squirrel', 'skateboard'];
        const TALL_HAZARDS = ['mailman', 'vet', 'cone', 'vacuum']; // height 50+ or width 60+
        const SMALL_HAZARDS = ['cat', 'squirrel', 'skateboard'];

        // Step 2.5 spawn pacing - PART 1: Anti-cluster spacing constants
        const BASE_REACTION_PX = 120;    // Minimum base spacing in pixels
        const SPEED_FACTOR_PX = 40;      // Additional spacing per gameSpeed unit
        const WIDTH_FACTOR = 0.8;        // Multiplier for obstacle width contribution
        const AIR_EXTRA_SPACING = 60;    // Extra spacing if air hazard involved
        const TALL_EXTRA_SPACING = 50;   // Extra spacing if tall hazard involved
        const SPEED_EXPONENT = 1.4;      // Nonlinear scaling exponent for gameSpeed
        const HARD_MIN_DISTANCE = 200;   // Absolute minimum px from spawnX regardless of timing
        const TALL_RECOVERY_FRAMES = 90; // Frames of recovery window after tall hazard (~1.5s)
        const RECOVERY_EXTRA_SPACING = 80; // Gameplay polish - extra spacing during recovery window

        // Step 2.5 spawn pacing - PART 2: Pacing timing constants
        const AIR_COOLDOWN = 3000;       // ms before another air hazard can spawn
        const TALL_COOLDOWN = 2500;      // ms before another tall hazard can spawn
        const BREATHER_INTERVAL = 4;     // Guarantee breather after this many consecutive spawns
        const BREATHER_DELAY = 1000;     // Extra delay ms for breather
        const PATTERN_SCORE_INTERVAL = 150; // Trigger pattern every N score points

        // ============================================================
        // DIFFICULTY CURVE SYSTEM - 3-Act emotional arc
        // Early: calm, learnable, forgiving
        // Mid: tense, focused, "barely made it"
        // Late: desperate but still fair
        // ============================================================

        // Debug flag for difficulty tuning
        const DEBUG_DIFFICULTY = false;

        // Speed curve constants - smooth 3-act progression
        const SPEED_START = 1.0;         // Starting game speed
        const SPEED_MID = 1.6;           // Speed at mid-game tension point (tuned up from 1.5)
        const SPEED_MAX = 2.3;           // Maximum speed (asymptotic limit)
        const RAMP_SCORE_START = 0;      // Score where ramp begins
        const RAMP_SCORE_MID = 300;      // Score at mid-game (tension builds) - tuned down from 400
        const RAMP_SCORE_END = 1200;     // Score where speed approaches max (asymptotic)

        // Difficulty tier thresholds - TUNED for earlier MID tension
                const TIER_EARLY_END = 220;      // End of early/calm phase
        const TIER_MID_END = 750;        // End of mid/tension phase (was 600, extended MID duration)

        // Tier-based spawn timing (ms) - TUNED for tenser MID
        const SPAWN_DELAY_EARLY = { base: 2800, min: 2000 };  // Unchanged - keep EARLY calm
                const SPAWN_DELAY_MID = { base: 2200, min: 1500 };    // Mid pacing
                const SPAWN_DELAY_LATE = { base: 1600, min: 1100 };   // Late pacing

        // Tier-based spacing multipliers (applied to base spacing) - TUNED for tenser MID
        const SPACING_MULT_EARLY = 1.3;  // 30% more spacing in early game - unchanged
                const SPACING_MULT_MID = 1.0;   // Mid spacing
                const SPACING_MULT_LATE = 0.9;  // Late spacing

        // Tier-based minimum survivable gap (absolute floor) - PRESERVED for fairness
        const MIN_SURVIVABLE_GAP_EARLY = 280;  // Unchanged - safety first
                const MIN_SURVIVABLE_GAP_MID = 240;    // Mid survivable floor
        const MIN_SURVIVABLE_GAP_LATE = 200;   // Unchanged - absolute floor

        // Tier-based hazard probabilities - TUNED for more "hard moments" in MID
        const AIR_HAZARD_CHANCE_EARLY = 0.15;   // 15% chance - unchanged
                const AIR_HAZARD_CHANCE_MID = 0.28;     // Mid air hazard chance
                const AIR_HAZARD_CHANCE_LATE = 0.38;    // Late air hazard chance
        const TALL_HAZARD_CHANCE_EARLY = 0.20;  // 20% chance - unchanged
                const TALL_HAZARD_CHANCE_MID = 0.35;    // Mid tall hazard chance
                const TALL_HAZARD_CHANCE_LATE = 0.42;   // Late tall hazard chance

        // Post-hard-hazard breather settings
        const POST_HARD_BREATHER_DELAY = 400;   // Extra ms delay after tall/air hazard
        const POST_HARD_SMALL_ONLY_CHANCE = 0.6; // 60% chance next spawn is small-only after hard hazard
        let lastHardHazardTime = 0;             // Track when last hard hazard spawned

        // Consecutive spawn limiting by tier
        const MAX_CONSECUTIVE_EARLY = 2;
        const MAX_CONSECUTIVE_MID = 3;
        const MAX_CONSECUTIVE_LATE = 4;

        // Get current difficulty tier based on score
        function getDifficultyTier(currentScore) {
            if (currentScore < TIER_EARLY_END) return 'EARLY';
            if (currentScore < TIER_MID_END) return 'MID';
            return 'LATE';
        }

        // Calculate smooth 3-act speed curve using logistic-style sigmoid
        // This creates: slow ramp early â†’ steep ramp mid â†’ asymptotic late
        function calculateGameSpeed(currentScore) {
            if (currentScore <= RAMP_SCORE_START) return SPEED_START;

            // Normalized progress through the difficulty curve (0 to ~1+)
            const progress = (currentScore - RAMP_SCORE_START) / (RAMP_SCORE_END - RAMP_SCORE_START);

            // Sigmoid curve: slow start, steep middle, asymptotic end
            // Using modified logistic: speed = start + (max-start) * sigmoid(progress)
            // TUNED: Sigmoid centered earlier for faster MID-game tension buildup
            const k = 7; // Steepness of the curve (was 6, now steeper for sharper MID ramp)
            const midpoint = 0.22; // Where the curve is steepest (was 0.35, now earlier for tension by ~250)
            const sigmoid = 1 / (1 + Math.exp(-k * (progress - midpoint)));

            // Map sigmoid (0-1) to speed range
            const speed = SPEED_START + (SPEED_MAX - SPEED_START) * sigmoid;

            return Math.min(SPEED_MAX, Math.max(SPEED_START, speed));
        }

        // Get tier-specific spawn delay parameters
        function getSpawnDelayParams(tier) {
            switch (tier) {
                case 'EARLY': return SPAWN_DELAY_EARLY;
                case 'MID': return SPAWN_DELAY_MID;
                case 'LATE': return SPAWN_DELAY_LATE;
                default: return SPAWN_DELAY_MID;
            }
        }

        // Get tier-specific spacing multiplier
        function getSpacingMultiplier(tier) {
            switch (tier) {
                case 'EARLY': return SPACING_MULT_EARLY;
                case 'MID': return SPACING_MULT_MID;
                case 'LATE': return SPACING_MULT_LATE;
                default: return SPACING_MULT_MID;
            }
        }

        // Get tier-specific minimum survivable gap
        function getMinSurvivableGap(tier) {
            switch (tier) {
                case 'EARLY': return MIN_SURVIVABLE_GAP_EARLY;
                case 'MID': return MIN_SURVIVABLE_GAP_MID;
                case 'LATE': return MIN_SURVIVABLE_GAP_LATE;
                default: return MIN_SURVIVABLE_GAP_MID;
            }
        }

        // Get tier-specific max consecutive spawns before forced breather
        function getMaxConsecutive(tier) {
            switch (tier) {
                case 'EARLY': return MAX_CONSECUTIVE_EARLY;
                case 'MID': return MAX_CONSECUTIVE_MID;
                case 'LATE': return MAX_CONSECUTIVE_LATE;
                default: return MAX_CONSECUTIVE_MID;
            }
        }

        // Check if obstacle type is "hard" (tall or air)
        function isHardHazard(obstacleType) {
            if (!obstacleType) return false;
            return TALL_HAZARDS.includes(obstacleType.id) || AIR_HAZARDS.includes(obstacleType.id);
        }

        // Debug logging for difficulty system
        let lastLoggedTier = null;
        function logDifficulty(tier, speed, minSpacing, spawnDelay, extraInfo = '') {
            if (!DEBUG_DIFFICULTY) return;
            // Only log on tier change or periodically
            if (tier !== lastLoggedTier) {
                console.log(`[DIFFICULTY] Tier changed to: ${tier}`);
                lastLoggedTier = tier;
            }
            console.log(`[DIFFICULTY] tier=${tier} speed=${speed.toFixed(2)} minSpacing=${minSpacing.toFixed(0)} spawnDelay=${spawnDelay.toFixed(0)}${extraInfo}`);
        }

        // Jump feel improvement - timing variables
        let lastGroundedTime = 0;    // Tracks when player was last on ground
        let jumpBufferTime = 0;      // Tracks when player last attempted to jump
        const COYOTE_TIME = 100;     // ms - allows jump shortly after leaving ground
        const JUMP_BUFFER_TIME = 100; // ms - queues jump if released just before landing
        const MIN_JUMP_VELOCITY = 6; // Ensures short taps still produce a visible hop
        const GRAVITY_UP = 0.50;     // Gentler gravity while rising (ease-out feel)
        const GRAVITY_DOWN = 0.85;   // Stronger gravity while falling (snappier descent)

        // Visual pass - obstacle SVGs with consistent outlines for silhouette readability
        const scaryThings = [
            // Visual pass: Mailman with stronger outline, simplified details
            { id: 'mailman', width: 45, height: 75, groundY: 9,
                svg: `<svg viewBox="0 0 45 75"><g stroke="#2A1A10" stroke-width="1.5"><rect x="10" y="52" width="9" height="23" rx="3" fill="#1A1A1A"/><rect x="26" y="52" width="9" height="23" rx="3" fill="#1A1A1A"/><ellipse cx="22" cy="38" rx="13" ry="18" fill="#CC2020"/><rect x="9" y="28" width="8" height="14" rx="2" fill="#8B4513" stroke-width="1"/><circle cx="22" cy="14" r="10" fill="#FFDAB9"/><rect x="10" y="3" width="24" height="12" rx="3" fill="#1A3A6E"/><ellipse cx="22" cy="6" rx="10" ry="3" fill="#1A3A6E" stroke="none"/></g><rect x="18" y="0" width="8" height="4" fill="#CC2020"/><ellipse cx="17" cy="13" rx="2.5" ry="3" fill="#2A1810"/><ellipse cx="27" cy="13" rx="2.5" ry="3" fill="#2A1810"/><path d="M 19 18 Q 22 20 25 18" stroke="#5A3A2A" stroke-width="2" fill="none"/><rect x="30" y="35" width="12" height="9" fill="#FFF8DC" stroke="#8B6914" stroke-width="1.5"/></svg>` },
            // Visual pass: Vacuum with stronger outline
            { id: 'vacuum', width: 60, height: 50, groundY: 9,
                svg: `<svg viewBox="0 0 60 50"><g stroke="#1A1A1A" stroke-width="1.5"><ellipse cx="30" cy="40" rx="25" ry="10" fill="#3A3A3A"/><rect x="20" y="8" width="20" height="32" rx="7" fill="#E05040"/></g><ellipse cx="30" cy="38" rx="21" ry="8" fill="#4D4D4D"/><rect x="24" y="13" width="12" height="8" rx="2" fill="#222" stroke="#1A1A1A" stroke-width="1"/><circle cx="30" cy="17" r="3" fill="#FF6B6B"><animate attributeName="opacity" values="1;0.3;1" dur="0.4s" repeatCount="indefinite"/></circle><path d="M 12 35 Q 0 27 5 15" stroke="#3A3A3A" stroke-width="6" fill="none" stroke-linecap="round"/><ellipse cx="5" cy="13" rx="5" ry="3" fill="#444" stroke="#222" stroke-width="1"/></svg>` },
            // Visual pass: Pigeon with stronger outline
            { id: 'pigeon', width: 40, height: 35, groundY: 25,
                svg: `<svg viewBox="0 0 40 35"><g stroke="#3A3A3A" stroke-width="1.2"><ellipse cx="22" cy="24" rx="14" ry="9" fill="#707070"/><circle cx="10" cy="17" r="9" fill="#808080"/></g><ellipse cx="4" cy="20" rx="5" ry="3" fill="#909090"/><circle cx="7" cy="15" r="3" fill="#FF8C00" stroke="#CC6600" stroke-width="1"/><circle cx="9" cy="14" r="1.5" fill="#111"/><path d="M 34 26 L 40 22 L 38 26 L 40 30 L 34 26" fill="#606060" stroke="#3A3A3A" stroke-width="1"/><path d="M 30 20 Q 38 15 36 22" fill="#707070"/></svg>` },
            // Visual pass: Thunder with stronger cloud outline
            { id: 'thunder', width: 70, height: 50, groundY: 35,
                svg: `<svg viewBox="0 0 70 50"><g stroke="#3A4558" stroke-width="1.5"><ellipse cx="35" cy="20" rx="32" ry="18" fill="#5A6578"/><ellipse cx="18" cy="23" rx="16" ry="13" fill="#4A5568"/><ellipse cx="52" cy="23" rx="14" ry="11" fill="#4A5568"/></g><ellipse cx="35" cy="17" rx="22" ry="10" fill="#6A7588"/><path d="M 32 32 L 40 32 L 35 42 L 46 42 L 28 58 L 36 44 L 24 44 Z" fill="#FFD700" stroke="#CC9900" stroke-width="1"><animate attributeName="opacity" values="1;0.2;1;0.4;1" dur="0.3s" repeatCount="indefinite"/></path></svg>` },
            // Visual pass: Cat with stronger outline
            { id: 'cat', width: 48, height: 45, groundY: 9,
                svg: `<svg viewBox="0 0 48 45"><g stroke="#2A2A2A" stroke-width="1.2"><ellipse cx="30" cy="32" rx="16" ry="10" fill="#4A4A4A"/><path d="M 44 26 Q 54 20 48 32" fill="#4A4A4A"/><circle cx="15" cy="20" r="12" fill="#4A4A4A"/></g><ellipse cx="17" cy="34" rx="7" ry="9" fill="#4A4A4A"/><polygon points="5,18 2,4 12,12" fill="#4A4A4A" stroke="#2A2A2A" stroke-width="1"/><polygon points="26,16 31,3 22,10" fill="#4A4A4A" stroke="#2A2A2A" stroke-width="1"/><polygon points="7,16 4,7 11,11" fill="#FF9090"/><polygon points="25,14 29,6 22,10" fill="#FF9090"/><ellipse cx="10" cy="18" rx="4" ry="5" fill="#90EE90" stroke="#50AA50" stroke-width="0.8"/><ellipse cx="21" cy="18" rx="4" ry="5" fill="#90EE90" stroke="#50AA50" stroke-width="0.8"/><ellipse cx="10" cy="18" rx="1.5" ry="4" fill="#111"/><ellipse cx="21" cy="18" rx="1.5" ry="4" fill="#111"/><ellipse cx="15" cy="25" rx="3" ry="2" fill="#FFB6C1"/></svg>` },
            // Visual pass: Cone with stronger outline
            { id: 'cone', width: 45, height: 50, groundY: 9,
                svg: `<svg viewBox="0 0 45 50"><ellipse cx="22" cy="45" rx="20" ry="5" fill="#D8D8D8" stroke="#A0A0A0" stroke-width="1.5"/><path d="M 2 45 L 15 10 L 30 10 L 43 45 Z" fill="#E8F4F8" stroke="#A0B0B8" stroke-width="2"/><ellipse cx="22" cy="10" rx="8" ry="3" fill="#E8F4F8" stroke="#A0B0B8" stroke-width="1.5"/><circle cx="22" cy="32" r="7" fill="#FFDAB9" stroke="#C0A080" stroke-width="1"/><ellipse cx="20" cy="31" rx="2" ry="2.5" fill="#2A1A10"/><ellipse cx="24" cy="31" rx="2" ry="2.5" fill="#2A1A10"/><ellipse cx="22" cy="36" rx="2.5" ry="1.5" fill="#2A1A10"/></svg>` },
            // Visual pass: Vet with stronger outline
            { id: 'vet', width: 40, height: 70, groundY: 9,
                svg: `<svg viewBox="0 0 40 70"><g stroke="#1A1A1A" stroke-width="1.5"><rect x="8" y="50" width="8" height="20" rx="3" fill="#1A1A1A"/><rect x="24" y="50" width="8" height="20" rx="3" fill="#1A1A1A"/><ellipse cx="20" cy="35" rx="12" ry="18" fill="#FFFFFF"/><circle cx="20" cy="12" r="9" fill="#FFDAB9"/></g><rect x="14" y="25" width="12" height="15" fill="#FFFFFF"/><ellipse cx="16" cy="11" rx="2.5" ry="2.5" fill="#2A1A10"/><ellipse cx="24" cy="11" rx="2.5" ry="2.5" fill="#2A1A10"/><path d="M 18 15 Q 20 17 22 15" stroke="#5A3A2A" stroke-width="1.5" fill="none"/><rect x="30" y="28" width="12" height="4" rx="1" fill="#C0C0C0" stroke="#808080" stroke-width="1"/><rect x="38" y="26" width="4" height="8" rx="1" fill="#A0A0A0"/><rect x="15" y="30" width="5" height="7" fill="#FF4444" stroke="#CC2222" stroke-width="0.8"/><rect x="17.5" y="28" width="1" height="11" fill="#FF4444"/></svg>` },
            // Visual pass: Squirrel with stronger outline
            { id: 'squirrel', width: 40, height: 45, groundY: 9,
                svg: `<svg viewBox="0 0 40 45"><g stroke="#5A4010" stroke-width="1.2"><path d="M 5 15 Q 0 5 8 8 Q 15 5 12 18" fill="#8B6914"/><ellipse cx="20" cy="30" rx="12" ry="10" fill="#A07828"/><circle cx="15" cy="18" r="10" fill="#A07828"/></g><ellipse cx="25" cy="35" rx="5" ry="7" fill="#A07828"/><ellipse cx="15" cy="36" rx="4" ry="6" fill="#A07828"/><ellipse cx="10" cy="10" rx="4" ry="5" fill="#A07828" stroke="#5A4010" stroke-width="0.8"/><ellipse cx="20" cy="10" rx="4" ry="5" fill="#A07828" stroke="#5A4010" stroke-width="0.8"/><ellipse cx="10" cy="10" rx="2" ry="3" fill="#C09038"/><ellipse cx="20" cy="10" rx="2" ry="3" fill="#C09038"/><ellipse cx="10" cy="17" rx="3.5" ry="4" fill="#FFFFFF" stroke="#888" stroke-width="0.5"/><ellipse cx="19" cy="17" rx="3.5" ry="4" fill="#FFFFFF" stroke="#888" stroke-width="0.5"/><circle cx="11" cy="18" r="2.5" fill="#111"/><circle cx="20" cy="18" r="2.5" fill="#111"/><ellipse cx="14" cy="23" rx="2.5" ry="2" fill="#2A1A10"/><ellipse cx="20" cy="28" rx="8" ry="5" fill="#C09038"/></svg>` },
            // Visual pass: Balloon with stronger outline
            { id: 'balloon', width: 38, height: 60, groundY: 12,
                svg: `<svg viewBox="0 0 38 60"><path d="M 19 55 Q 19 48 19 45" stroke="#6B4520" stroke-width="2" fill="none"/><ellipse cx="19" cy="24" rx="17" ry="22" fill="#FF6B6B" stroke="#CC4040" stroke-width="1.5"/><ellipse cx="19" cy="21" rx="13" ry="17" fill="#FF8585"/><ellipse cx="14" cy="17" rx="5" ry="8" fill="rgba(255,255,255,0.4)"/><polygon points="19,46 14,41 24,41" fill="#FF6B6B" stroke="#CC4040" stroke-width="1"/></svg>` },
            // Visual pass: Skateboard with stronger outline
            { id: 'skateboard', width: 65, height: 22, groundY: 9,
                svg: `<svg viewBox="0 0 65 22"><rect x="5" y="5" width="55" height="8" rx="4" fill="#A0522D" stroke="#6A3010" stroke-width="1.5"/><rect x="8" y="6" width="49" height="5" rx="2" fill="#B8652D"/><rect x="12" y="13" width="10" height="3" fill="#222" stroke="#111" stroke-width="0.8"/><rect x="43" y="13" width="10" height="3" fill="#222" stroke="#111" stroke-width="0.8"/><circle cx="15" cy="19" r="4" fill="#1A1A1A" stroke="#000" stroke-width="1"/><circle cx="50" cy="19" r="4" fill="#1A1A1A" stroke="#000" stroke-width="1"/></svg>` },
            // Visual pass: Umbrella with stronger outline
            { id: 'umbrella', width: 55, height: 55, groundY: 25,
                svg: `<svg viewBox="0 0 55 55"><path d="M 27 8 Q 5 12 5 28 Q 5 32 10 32 Q 12 28 15 28 Q 18 28 20 32 Q 22 28 27 28 Q 32 28 34 32 Q 36 28 39 28 Q 42 28 44 32 Q 49 32 49 28 Q 49 12 27 8 Z" fill="#CC2020" stroke="#8A1010" stroke-width="1.5"/><ellipse cx="27" cy="10" rx="8" ry="3" fill="#DD3030"/><line x1="27" y1="8" x2="27" y2="48" stroke="#6B3510" stroke-width="3"/><path d="M 27 48 Q 22 52 20 48" stroke="#6B3510" stroke-width="3" fill="none" stroke-linecap="round"/></svg>` },
            // Visual pass: Frisbee with stronger outline
            // CHANGE: Lowered groundY from 20 to 17 (~12px lower) so it hits non-jumping Tater
            { id: 'frisbee', width: 50, height: 24, groundY: 17,
                svg: `<svg viewBox="0 0 50 24"><ellipse cx="25" cy="12" rx="24" ry="11" fill="#3498DB" stroke="#1A6090" stroke-width="1.5"/><ellipse cx="25" cy="10" rx="20" ry="8" fill="#5DADE2"/><ellipse cx="25" cy="9" rx="14" ry="5" fill="#85C1E9"/><ellipse cx="25" cy="14" rx="22" ry="9" fill="none" stroke="#2980B9" stroke-width="2"/><ellipse cx="20" cy="8" rx="5" ry="2.5" fill="rgba(255,255,255,0.35)"/></svg>` }
        ];

        // Visual pass - bone SVGs with consistent outline
        const boneSVG = `<svg viewBox="0 0 45 26"><g stroke="#B8A070" stroke-width="1.2"><ellipse cx="7" cy="6" rx="7" ry="5" fill="#F5DEB3"/><ellipse cx="7" cy="20" rx="7" ry="5" fill="#F5DEB3"/><ellipse cx="38" cy="6" rx="7" ry="5" fill="#F5DEB3"/><ellipse cx="38" cy="20" rx="7" ry="5" fill="#F5DEB3"/><rect x="7" y="6" width="31" height="14" fill="#F5DEB3" stroke="none"/></g><ellipse cx="7" cy="6" rx="4" ry="3" fill="#FFF8DC"/><ellipse cx="38" cy="6" rx="4" ry="3" fill="#FFF8DC"/><ellipse cx="22" cy="13" rx="7" ry="4" fill="#FFE4B5"/></svg>`;
        const lifeBoneSVG = `<svg viewBox="0 0 34 20"><g stroke="#5A4A30" stroke-width="1"><ellipse cx="5" cy="5" rx="5" ry="4" fill="#8B6B50"/><ellipse cx="5" cy="15" rx="5" ry="4" fill="#8B6B50"/><ellipse cx="29" cy="5" rx="5" ry="4" fill="#8B6B50"/><ellipse cx="29" cy="15" rx="5" ry="4" fill="#8B6B50"/><rect x="5" y="5" width="24" height="10" fill="#8B6B50" stroke="none"/></g><ellipse cx="5" cy="5" rx="3" ry="2.5" fill="#A08060"/><ellipse cx="29" cy="5" rx="3" ry="2.5" fill="#A08060"/></svg>`;

        function generateBackground() {
            // Seamless parallax fix: clear all layers first
            const clouds = document.getElementById('clouds');
            const far = document.getElementById('landmarksFar');
            const mid = document.getElementById('landmarksMid');
            const park = document.getElementById('parkElements');
            clouds.innerHTML = '';
            far.innerHTML = '';
            mid.innerHTML = '';
            park.innerHTML = '';

            // Mobile clutter reduction: fewer background elements on small screens
            const isSmallScreen = window.innerWidth <= 520;

            // Helper: duplicate elements for seamless 300% width tiling (3 segments)
            function duplicateForSeamless(container, baseWidth) {
                const children = Array.from(container.children);
                children.forEach(child => {
                    const currentLeft = parseFloat(child.style.left) || 0;
                    // First clone at baseWidth offset
                    const clone1 = child.cloneNode(true);
                    clone1.style.left = (currentLeft + baseWidth) + 'px';
                    container.appendChild(clone1);
                    // Second clone at 2*baseWidth offset
                    const clone2 = child.cloneNode(true);
                    clone2.style.left = (currentLeft + baseWidth * 2) + 'px';
                    container.appendChild(clone2);
                });
            }

            // CLOUDS - generate for first half, then duplicate
            const cloudBaseWidth = window.innerWidth;
            const cloudPositions = generateVariedPositions(6, cloudBaseWidth, 90, 120);
            for (let i = 0; i < 6; i++) {
                const c = document.createElement('div');
                c.className = 'cloud';
                const j = getElementJitter('cloud');
                const baseWidth = 60 + Math.random() * 100;
                const baseHeight = 25 + Math.random() * 35;
                c.style.cssText = `left:${cloudPositions[i]}px;top:${5+Math.random()*90}px;width:${baseWidth * j.scale}px;height:${baseHeight * j.scale}px;opacity:${0.7 + Math.random()*0.3 * j.opacity}`;
                clouds.appendChild(c);
            }
            duplicateForSeamless(clouds, cloudBaseWidth);

            // Helper: generate non-adjacent placement indices for variety
            // Returns an array of indices that avoids placing the same SVG type adjacent
            // Uses random selection (runs only at generation time, not per-frame)
            function generateNonAdjacentIndices(count, svgArrayLength) {
                const indices = [];
                let lastIdx = -1;
                for (let i = 0; i < count; i++) {
                    // Build pool of valid choices (exclude last used index)
                    const pool = [];
                    for (let j = 0; j < svgArrayLength; j++) {
                        if (j !== lastIdx) pool.push(j);
                    }
                    // Random selection from pool for natural variety
                    const pick = pool[Math.floor(Math.random() * pool.length)];
                    indices.push(pick);
                    lastIdx = pick;
                }
                return indices;
            }

            // Helper: generate subtle per-element jitter for visual variety
            // Only called at creation time, not per-frame (safe for performance)
            function getElementJitter(layer) {
                const jitter = {
                    cloud: { yRange: 8,  scaleRange: 0.15, opacityRange: 0.25 },
                    far:   { yRange: 15, scaleRange: 0.18, opacityRange: 0.18 },
                    mid:   { yRange: 10, scaleRange: 0.12, opacityRange: 0.12 },
                    park:  { yRange: 8,  scaleRange: 0.10, opacityRange: 0.10 }
                };
                const j = jitter[layer] || jitter.mid;
                return {
                    y: (Math.random() - 0.5) * 2 * j.yRange,
                    scale: 1 + (Math.random() - 0.5) * 2 * j.scaleRange,
                    opacity: 1 - Math.random() * j.opacityRange
                };
            }

            // Helper: generate varied x positions with clustering + gaps (breaks even cadence)
            // Runs once at generation time. Positions stay within [0, baseWidth - margin].
            function generateVariedPositions(count, baseWidth, minSep, margin) {
                const maxX = baseWidth - margin;
                const positions = [];
                // Start with even distribution, then apply controlled variance
                const avgSlot = maxX / count;
                for (let i = 0; i < count; i++) {
                    // Base position with strong variance: allow Â±45% of slot width shift
                    // Plus occasional clustering bias (30% chance to pull toward neighbor)
                    const base = i * avgSlot;
                    let variance = (Math.random() - 0.5) * avgSlot * 0.9;
                    // Clustering: occasionally pull toward previous position for natural grouping
                    if (i > 0 && Math.random() < 0.3) {
                        variance *= 0.4; // reduce variance = cluster with previous
                    }
                    let x = base + variance;
                    // Clamp to valid range
                    x = Math.max(0, Math.min(maxX, x));
                    positions.push(x);
                }
                // Sort and enforce minimum separation (push apart if too close)
                positions.sort((a, b) => a - b);
                for (let i = 1; i < positions.length; i++) {
                    if (positions[i] - positions[i-1] < minSep) {
                        positions[i] = Math.min(maxX, positions[i-1] + minSep);
                    }
                }
                // Shuffle to break left-to-right correlation with indices
                for (let i = positions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [positions[i], positions[j]] = [positions[j], positions[i]];
                }
                return positions;
            }

            // FAR LAYER - London skyline with iconic landmarks + terraced roofs with chimneys
            const farSVGs = [
                // Big Ben / Elizabeth Tower silhouette
                `<svg width="45" height="160" viewBox="0 0 45 160"><rect x="12" y="30" width="21" height="130" fill="#8090A0" opacity="0.45"/><rect x="8" y="25" width="29" height="12" fill="#8090A0" opacity="0.45"/><rect x="17" y="10" width="11" height="18" fill="#8090A0" opacity="0.45"/><polygon points="22.5,0 14,10 31,10" fill="#8090A0" opacity="0.45"/><circle cx="22.5" cy="45" r="7" fill="#A0B0C0" opacity="0.35"/><rect x="20" y="60" width="5" height="8" fill="#A0B0C0" opacity="0.3"/><rect x="20" y="80" width="5" height="8" fill="#A0B0C0" opacity="0.3"/><rect x="20" y="100" width="5" height="8" fill="#A0B0C0" opacity="0.3"/></svg>`,
                // Terraced townhouse row with chimneys (London recognizable)
                `<svg width="120" height="100" viewBox="0 0 120 100"><rect x="2" y="30" width="28" height="70" fill="#9898A0" opacity="0.42"/><rect x="32" y="25" width="28" height="75" fill="#A0A098" opacity="0.42"/><rect x="62" y="35" width="28" height="65" fill="#9090A0" opacity="0.42"/><rect x="92" y="28" width="26" height="72" fill="#A8A0A0" opacity="0.42"/><rect x="8" y="20" width="4" height="12" fill="#707078" opacity="0.5"/><rect x="18" y="18" width="4" height="14" fill="#707078" opacity="0.5"/><rect x="40" y="15" width="4" height="12" fill="#707078" opacity="0.5"/><rect x="52" y="17" width="4" height="10" fill="#707078" opacity="0.5"/><rect x="70" y="25" width="4" height="12" fill="#707078" opacity="0.5"/><rect x="82" y="27" width="4" height="10" fill="#707078" opacity="0.5"/><rect x="100" y="18" width="4" height="12" fill="#707078" opacity="0.5"/><rect x="110" y="20" width="4" height="10" fill="#707078" opacity="0.5"/><rect x="8" y="45" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="18" y="45" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="40" y="40" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="50" y="40" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="70" y="50" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="80" y="50" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="100" y="43" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="110" y="43" width="6" height="10" fill="#B0A8A0" opacity="0.3"/></svg>`,
                // London Eye silhouette
                `<svg width="100" height="130" viewBox="0 0 100 130"><circle cx="50" cy="55" r="48" fill="none" stroke="#9098A8" stroke-width="3" opacity="0.4"/><rect x="46" y="103" width="8" height="27" fill="#808890" opacity="0.4"/><line x1="50" y1="7" x2="50" y2="103" stroke="#9098A8" stroke-width="1.5" opacity="0.3"/><line x1="2" y1="55" x2="98" y2="55" stroke="#9098A8" stroke-width="1.5" opacity="0.3"/><ellipse cx="50" cy="15" rx="4" ry="6" fill="#A0A8B0" opacity="0.35"/><ellipse cx="50" cy="95" rx="4" ry="6" fill="#A0A8B0" opacity="0.35"/><ellipse cx="10" cy="55" rx="4" ry="6" fill="#A0A8B0" opacity="0.35"/><ellipse cx="90" cy="55" rx="4" ry="6" fill="#A0A8B0" opacity="0.35"/></svg>`,
                // More terraced houses with varied roofline
                `<svg width="100" height="95" viewBox="0 0 100 95"><rect x="2" y="32" width="30" height="63" fill="#A8A098" opacity="0.4"/><rect x="34" y="28" width="30" height="67" fill="#9898A0" opacity="0.4"/><rect x="66" y="35" width="32" height="60" fill="#A0A090" opacity="0.4"/><rect x="10" y="22" width="4" height="12" fill="#686870" opacity="0.5"/><rect x="22" y="24" width="4" height="10" fill="#686870" opacity="0.5"/><rect x="44" y="18" width="4" height="12" fill="#686870" opacity="0.5"/><rect x="54" y="20" width="4" height="10" fill="#686870" opacity="0.5"/><rect x="76" y="25" width="4" height="12" fill="#686870" opacity="0.5"/><rect x="88" y="27" width="4" height="10" fill="#686870" opacity="0.5"/><rect x="8" y="45" width="7" height="12" fill="#B8B0A8" opacity="0.3"/><rect x="19" y="45" width="7" height="12" fill="#B8B0A8" opacity="0.3"/><rect x="42" y="42" width="7" height="12" fill="#B8B0A8" opacity="0.3"/><rect x="53" y="42" width="7" height="12" fill="#B8B0A8" opacity="0.3"/><rect x="74" y="48" width="7" height="12" fill="#B8B0A8" opacity="0.3"/><rect x="85" y="48" width="7" height="12" fill="#B8B0A8" opacity="0.3"/><rect x="14" y="75" width="8" height="20" fill="#908880" opacity="0.35"/><rect x="46" y="70" width="8" height="25" fill="#908880" opacity="0.35"/><rect x="80" y="75" width="8" height="20" fill="#908880" opacity="0.35"/></svg>`,
                // Tower Bridge silhouette
                `<svg width="140" height="110" viewBox="0 0 140 110"><rect x="10" y="35" width="22" height="75" fill="#8090A0" opacity="0.4"/><rect x="108" y="35" width="22" height="75" fill="#8090A0" opacity="0.4"/><polygon points="21,35 10,20 32,20" fill="#8090A0" opacity="0.4"/><polygon points="119,35 108,20 130,20" fill="#8090A0" opacity="0.4"/><rect x="6" y="15" width="30" height="8" fill="#8090A0" opacity="0.4"/><rect x="104" y="15" width="30" height="8" fill="#8090A0" opacity="0.4"/><rect x="32" y="55" width="76" height="12" fill="#7888A0" opacity="0.35"/><path d="M 32 55 Q 70 35 108 55" stroke="#8090A0" stroke-width="4" fill="none" opacity="0.4"/><rect x="32" y="85" width="76" height="8" fill="#7888A0" opacity="0.35"/></svg>`,
                // St Paul's dome silhouette
                `<svg width="80" height="120" viewBox="0 0 80 120"><rect x="10" y="70" width="60" height="50" fill="#8898A8" opacity="0.4"/><ellipse cx="40" cy="50" rx="28" ry="25" fill="#8898A8" opacity="0.4"/><ellipse cx="40" cy="35" rx="12" ry="18" fill="#9098A8" opacity="0.4"/><rect x="36" y="10" width="8" height="12" fill="#8898A8" opacity="0.4"/><circle cx="40" cy="8" r="4" fill="#9098A8" opacity="0.35"/><rect x="15" y="80" width="8" height="12" fill="#98A0B0" opacity="0.3"/><rect x="57" y="80" width="8" height="12" fill="#98A0B0" opacity="0.3"/></svg>`,
                // The Shard silhouette
                `<svg width="35" height="150" viewBox="0 0 35 150"><polygon points="17.5,0 5,150 30,150" fill="#7888A0" opacity="0.4"/><line x1="17.5" y1="20" x2="17.5" y2="145" stroke="#8898B0" stroke-width="1" opacity="0.3"/><line x1="10" y1="50" x2="25" y2="50" stroke="#8898B0" stroke-width="1" opacity="0.25"/><line x1="8" y1="90" x2="27" y2="90" stroke="#8898B0" stroke-width="1" opacity="0.25"/></svg>`,
                // More townhouses with chimneys
                `<svg width="90" height="90" viewBox="0 0 90 90"><rect x="2" y="28" width="26" height="62" fill="#9898A0" opacity="0.42"/><rect x="30" y="32" width="28" height="58" fill="#A0A098" opacity="0.42"/><rect x="60" y="25" width="28" height="65" fill="#A898A0" opacity="0.42"/><rect x="8" y="18" width="4" height="12" fill="#707078" opacity="0.5"/><rect x="20" y="20" width="4" height="10" fill="#707078" opacity="0.5"/><rect x="38" y="22" width="4" height="12" fill="#707078" opacity="0.5"/><rect x="50" y="24" width="4" height="10" fill="#707078" opacity="0.5"/><rect x="68" y="15" width="4" height="12" fill="#707078" opacity="0.5"/><rect x="80" y="17" width="4" height="10" fill="#707078" opacity="0.5"/><rect x="6" y="42" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="16" y="42" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="36" y="46" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="46" y="46" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="66" y="40" width="6" height="10" fill="#B0A8A0" opacity="0.3"/><rect x="76" y="40" width="6" height="10" fill="#B0A8A0" opacity="0.3"/></svg>`,
                // NEW: The Gherkin (30 St Mary Axe) silhouette
                `<svg width="40" height="130" viewBox="0 0 40 130"><ellipse cx="20" cy="65" rx="18" ry="60" fill="#8090A0" opacity="0.4"/><ellipse cx="20" cy="10" rx="8" ry="8" fill="#8898B0" opacity="0.35"/><line x1="8" y1="30" x2="32" y2="30" stroke="#7080A0" stroke-width="1" opacity="0.25"/><line x1="5" y1="50" x2="35" y2="50" stroke="#7080A0" stroke-width="1" opacity="0.25"/><line x1="4" y1="70" x2="36" y2="70" stroke="#7080A0" stroke-width="1" opacity="0.25"/><line x1="5" y1="90" x2="35" y2="90" stroke="#7080A0" stroke-width="1" opacity="0.25"/><line x1="8" y1="110" x2="32" y2="110" stroke="#7080A0" stroke-width="1" opacity="0.25"/><path d="M 10 20 Q 20 65 10 115" stroke="#7888A0" stroke-width="1" fill="none" opacity="0.3"/><path d="M 30 20 Q 20 65 30 115" stroke="#7888A0" stroke-width="1" fill="none" opacity="0.3"/></svg>`,
                // NEW: Westminster Bridge span with lampposts
                `<svg width="160" height="80" viewBox="0 0 160 80"><path d="M 0 70 Q 40 50 80 70 Q 120 50 160 70" stroke="#8090A0" stroke-width="6" fill="none" opacity="0.38"/><rect x="0" y="70" width="160" height="10" fill="#8898A8" opacity="0.35"/><rect x="38" y="35" width="4" height="35" fill="#707080" opacity="0.45"/><ellipse cx="40" cy="32" rx="5" ry="6" fill="#9098A8" opacity="0.4"/><rect x="78" y="30" width="4" height="40" fill="#707080" opacity="0.45"/><ellipse cx="80" cy="27" rx="5" ry="6" fill="#9098A8" opacity="0.4"/><rect x="118" y="35" width="4" height="35" fill="#707080" opacity="0.45"/><ellipse cx="120" cy="32" rx="5" ry="6" fill="#9098A8" opacity="0.4"/></svg>`,
                // NEW: Dense chimney pots cluster (Victorian industrial roofline)
                `<svg width="110" height="85" viewBox="0 0 110 85"><rect x="2" y="40" width="25" height="45" fill="#9090A0" opacity="0.4"/><rect x="29" y="35" width="25" height="50" fill="#9898A8" opacity="0.4"/><rect x="56" y="42" width="25" height="43" fill="#8888A0" opacity="0.4"/><rect x="83" y="38" width="25" height="47" fill="#9090A8" opacity="0.4"/><rect x="6" y="28" width="5" height="14" fill="#606068" opacity="0.5"/><rect x="14" y="30" width="5" height="12" fill="#606068" opacity="0.5"/><rect x="33" y="22" width="5" height="15" fill="#606068" opacity="0.5"/><rect x="41" y="25" width="5" height="12" fill="#606068" opacity="0.5"/><rect x="49" y="23" width="5" height="14" fill="#606068" opacity="0.5"/><rect x="60" y="30" width="5" height="14" fill="#606068" opacity="0.5"/><rect x="68" y="32" width="5" height="12" fill="#606068" opacity="0.5"/><rect x="76" y="30" width="5" height="14" fill="#606068" opacity="0.5"/><rect x="87" y="26" width="5" height="14" fill="#606068" opacity="0.5"/><rect x="95" y="28" width="5" height="12" fill="#606068" opacity="0.5"/><rect x="103" y="26" width="5" height="14" fill="#606068" opacity="0.5"/></svg>`,
                // RARE: Distant Canary Wharf cluster (very low contrast, atmospheric depth)
                `<svg width="90" height="140" viewBox="0 0 90 140"><rect x="35" y="20" width="20" height="120" fill="#A0A8B8" opacity="0.22"/><rect x="33" y="15" width="24" height="8" fill="#A0A8B8" opacity="0.2"/><polygon points="45,0 38,15 52,15" fill="#A8B0C0" opacity="0.18"/><rect x="10" y="50" width="18" height="90" fill="#98A0B0" opacity="0.2"/><rect x="62" y="45" width="18" height="95" fill="#98A0B0" opacity="0.2"/><rect x="5" y="70" width="12" height="70" fill="#9098A8" opacity="0.18"/><rect x="73" y="65" width="12" height="75" fill="#9098A8" opacity="0.18"/></svg>`,
                // RARE: Distant church spire with misty haze (atmospheric perspective)
                `<svg width="50" height="120" viewBox="0 0 50 120"><rect x="15" y="45" width="20" height="75" fill="#A8B0B8" opacity="0.2"/><rect x="10" y="40" width="30" height="8" fill="#A0A8B0" opacity="0.18"/><polygon points="25,0 18,40 32,40" fill="#A8B0C0" opacity="0.2"/><circle cx="25" cy="8" r="3" fill="#B0B8C0" opacity="0.15"/><rect x="18" y="60" width="6" height="10" fill="#B8C0C8" opacity="0.12"/><rect x="26" y="60" width="6" height="10" fill="#B8C0C8" opacity="0.12"/><ellipse cx="25" cy="115" rx="22" ry="5" fill="#C0C8D0" opacity="0.1"/></svg>`,
                // RARE: Foggy dome silhouette (very subtle, extends visual memory)
                `<svg width="70" height="100" viewBox="0 0 70 100"><ellipse cx="35" cy="50" rx="30" ry="25" fill="#A0A8B8" opacity="0.18"/><rect x="15" y="70" width="40" height="30" fill="#98A0B0" opacity="0.16"/><ellipse cx="35" cy="30" rx="12" ry="15" fill="#A8B0C0" opacity="0.15"/><rect x="32" y="12" width="6" height="10" fill="#A0A8B8" opacity="0.14"/><circle cx="35" cy="10" r="4" fill="#B0B8C0" opacity="0.12"/></svg>`
            ];
            const farBaseWidth = window.innerWidth;
            // Mobile clutter reduction: fewer FAR elements on small screens
            const farCount = isSmallScreen ? 3 : 6;
            const farMinSep = isSmallScreen ? 130 : 110;
            // FAR layer index generation: iconic landmarks appear at most ONCE per base segment
            // Iconic: Big Ben(0), London Eye(2), Tower Bridge(4), St Paul's(5), Shard(6), Gherkin(8)
            // Non-iconic fillers: terraces(1,3,7), bridge(9), chimneys(10), rare atmos(11,12,13)
            const iconicIndices = [0, 2, 4, 5, 6, 8];
            const nonIconicIndices = [1, 3, 7, 9, 10, 11, 12, 13];
            const farIndices = [];
            const usedIconic = new Set();
            // Guarantee at least 1 iconic landmark per segment (randomly chosen)
            const guaranteedIconic = iconicIndices[Math.floor(Math.random() * iconicIndices.length)];
            farIndices.push(guaranteedIconic);
            usedIconic.add(guaranteedIconic);
            // Add 1 non-iconic for variety
            farIndices.push(nonIconicIndices[Math.floor(Math.random() * nonIconicIndices.length)]);
            // Fill remaining slots, allowing iconic only once each
            while (farIndices.length < farCount) {
                const pool = [];
                // Add all non-iconic (always available)
                nonIconicIndices.forEach(idx => pool.push(idx));
                // Add iconic only if not yet used
                iconicIndices.forEach(idx => { if (!usedIconic.has(idx)) pool.push(idx); });
                const pick = pool[Math.floor(Math.random() * pool.length)];
                if (iconicIndices.includes(pick)) usedIconic.add(pick);
                farIndices.push(pick);
            }
            // Shuffle to break positional patterns (Fisher-Yates)
            for (let i = farIndices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [farIndices[i], farIndices[j]] = [farIndices[j], farIndices[i]];
            }
            const farPositions = generateVariedPositions(farCount, farBaseWidth, farMinSep, 160);
            // Clamp iconic landmarks away from edges to reduce "double landmark" at seams
            const edgeBuffer = farBaseWidth * 0.18; // 18% buffer from edges (increased for better seam hiding)
            for (let i = 0; i < farCount; i++) {
                if (iconicIndices.includes(farIndices[i])) {
                    farPositions[i] = Math.max(edgeBuffer, Math.min(farBaseWidth - 160 - edgeBuffer, farPositions[i]));
                }
            }
            for (let i = 0; i < farCount; i++) {
                const d = document.createElement('div');
                d.innerHTML = farSVGs[farIndices[i]];
                const j = getElementJitter('far');
                d.style.cssText = `position:absolute;left:${farPositions[i]}px;bottom:${j.y}px;transform:scale(${j.scale});opacity:${j.opacity}`;
                far.appendChild(d);
            }
            duplicateForSeamless(far, farBaseWidth);

            // MID LAYER - London cues: more phone boxes, cabs, lampposts, Underground signs
            const midSVGs = [
                // Red telephone box
                `<svg width="18" height="45" viewBox="0 0 18 45"><rect x="2" y="5" width="14" height="40" rx="1" fill="#CC2020" opacity="0.7"/><rect x="4" y="0" width="10" height="6" rx="1" fill="#CC2020" opacity="0.7"/><rect x="4" y="10" width="10" height="25" fill="#88AACC" opacity="0.4"/><rect x="6" y="12" width="2" height="8" fill="#6688AA" opacity="0.4"/><rect x="10" y="12" width="2" height="8" fill="#6688AA" opacity="0.4"/></svg>`,
                // Victorian lamppost
                `<svg width="14" height="60" viewBox="0 0 14 60"><rect x="5" y="18" width="4" height="42" fill="#2A2A2A" opacity="0.7"/><ellipse cx="7" cy="60" rx="6" ry="2" fill="#2A2A2A" opacity="0.6"/><path d="M 2 18 Q 2 8 7 6 Q 12 8 12 18" fill="#3A3A3A" opacity="0.7"/><ellipse cx="7" cy="10" rx="4" ry="5" fill="#FFE4A0" opacity="0.4"/><rect x="4" y="15" width="6" height="4" fill="#3A3A3A" opacity="0.7"/></svg>`,
                // Red double-decker bus
                `<svg width="55" height="38" viewBox="0 0 55 38"><rect x="4" y="12" width="47" height="26" rx="2" fill="#CC2020" opacity="0.75"/><rect x="4" y="5" width="40" height="14" rx="2" fill="#CC2020" opacity="0.75"/><rect x="8" y="8" width="8" height="8" fill="#88AACC" opacity="0.5"/><rect x="18" y="8" width="8" height="8" fill="#88AACC" opacity="0.5"/><rect x="28" y="8" width="8" height="8" fill="#88AACC" opacity="0.5"/><rect x="8" y="18" width="10" height="10" fill="#88AACC" opacity="0.5"/><rect x="22" y="18" width="10" height="10" fill="#88AACC" opacity="0.5"/><rect x="36" y="18" width="10" height="10" fill="#88AACC" opacity="0.5"/><circle cx="14" cy="36" r="3.5" fill="#222" opacity="0.8"/><circle cx="41" cy="36" r="3.5" fill="#222" opacity="0.8"/></svg>`,
                // Underground roundel sign
                `<svg width="24" height="55" viewBox="0 0 24 55"><rect x="10" y="25" width="4" height="30" fill="#1A1A1A" opacity="0.7"/><circle cx="12" cy="12" r="11" fill="none" stroke="#CC2020" stroke-width="4" opacity="0.75"/><rect x="2" y="8" width="20" height="8" fill="#1A3A6E" opacity="0.75"/></svg>`,
                // Black cab
                `<svg width="40" height="28" viewBox="0 0 40 28"><rect x="4" y="10" width="32" height="18" rx="3" fill="#1A1A1A" opacity="0.75"/><path d="M 8 10 Q 8 4 16 4 L 28 4 Q 32 4 32 10" fill="#1A1A1A" opacity="0.75"/><rect x="8" y="6" width="10" height="8" rx="1" fill="#88AACC" opacity="0.5"/><rect x="22" y="6" width="8" height="8" rx="1" fill="#88AACC" opacity="0.5"/><circle cx="10" cy="26" r="3" fill="#222" opacity="0.8"/><circle cx="30" cy="26" r="3" fill="#222" opacity="0.8"/></svg>`,
                // Victorian lamppost (variant with double lamp)
                `<svg width="18" height="60" viewBox="0 0 18 60"><rect x="7" y="18" width="4" height="42" fill="#2A2A2A" opacity="0.7"/><ellipse cx="9" cy="60" rx="6" ry="2" fill="#2A2A2A" opacity="0.6"/><path d="M 2 18 Q 2 10 9 8 Q 16 10 16 18" fill="#3A3A3A" opacity="0.7"/><ellipse cx="4" cy="12" rx="3" ry="4" fill="#FFE4A0" opacity="0.4"/><ellipse cx="14" cy="12" rx="3" ry="4" fill="#FFE4A0" opacity="0.4"/><rect x="5" y="15" width="8" height="4" fill="#3A3A3A" opacity="0.7"/></svg>`,
                // Park tree
                `<svg width="35" height="55" viewBox="0 0 35 55"><rect x="14" y="35" width="6" height="20" fill="#5D4423" opacity="0.8"/><ellipse cx="17" cy="22" rx="15" ry="20" fill="#3A7A3A" opacity="0.7"/><ellipse cx="12" cy="18" rx="8" ry="10" fill="#4A8A4A" opacity="0.6"/></svg>`,
                // Postbox (iconic British red)
                `<svg width="16" height="35" viewBox="0 0 16 35"><rect x="2" y="8" width="12" height="27" rx="2" fill="#CC2020" opacity="0.75"/><ellipse cx="8" cy="8" rx="6" ry="4" fill="#CC2020" opacity="0.75"/><rect x="4" y="14" width="8" height="3" fill="#1A1A1A" opacity="0.4"/><ellipse cx="8" cy="6" rx="3" ry="2" fill="#DD3030" opacity="0.6"/></svg>`,
                // Wrought iron railing section
                `<svg width="45" height="30" viewBox="0 0 45 30"><rect x="0" y="5" width="45" height="3" fill="#1A1A1A" opacity="0.6"/><rect x="0" y="25" width="45" height="3" fill="#1A1A1A" opacity="0.6"/><rect x="2" y="5" width="2" height="23" fill="#1A1A1A" opacity="0.6"/><rect x="12" y="5" width="2" height="23" fill="#1A1A1A" opacity="0.6"/><rect x="22" y="5" width="2" height="23" fill="#1A1A1A" opacity="0.6"/><rect x="32" y="5" width="2" height="23" fill="#1A1A1A" opacity="0.6"/><rect x="42" y="5" width="2" height="23" fill="#1A1A1A" opacity="0.6"/><ellipse cx="7" cy="12" rx="3" ry="4" fill="none" stroke="#1A1A1A" stroke-width="1.5" opacity="0.5"/><ellipse cx="17" cy="12" rx="3" ry="4" fill="none" stroke="#1A1A1A" stroke-width="1.5" opacity="0.5"/><ellipse cx="27" cy="12" rx="3" ry="4" fill="none" stroke="#1A1A1A" stroke-width="1.5" opacity="0.5"/><ellipse cx="37" cy="12" rx="3" ry="4" fill="none" stroke="#1A1A1A" stroke-width="1.5" opacity="0.5"/></svg>`,
                // Black cab (variant facing other way)
                `<svg width="40" height="28" viewBox="0 0 40 28"><rect x="4" y="10" width="32" height="18" rx="3" fill="#1A1A1A" opacity="0.75"/><path d="M 32 10 Q 32 4 24 4 L 12 4 Q 8 4 8 10" fill="#1A1A1A" opacity="0.75"/><rect x="10" y="6" width="8" height="8" rx="1" fill="#88AACC" opacity="0.5"/><rect x="22" y="6" width="10" height="8" rx="1" fill="#88AACC" opacity="0.5"/><circle cx="10" cy="26" r="3" fill="#222" opacity="0.8"/><circle cx="30" cy="26" r="3" fill="#222" opacity="0.8"/></svg>`,
                // Bollard (simple street furniture)
                `<svg width="12" height="28" viewBox="0 0 12 28"><rect x="3" y="8" width="6" height="20" fill="#1A1A1A" opacity="0.7"/><ellipse cx="6" cy="8" rx="5" ry="3" fill="#2A2A2A" opacity="0.7"/><ellipse cx="6" cy="28" rx="5" ry="2" fill="#1A1A1A" opacity="0.6"/></svg>`
            ];
            const midBaseWidth = window.innerWidth;
            const midCount = isSmallScreen ? 5 : 8;
            const midIndices = generateNonAdjacentIndices(midCount, midSVGs.length);
            const midPositions = generateVariedPositions(midCount, midBaseWidth, 65, 70);
            for (let i = 0; i < midCount; i++) {
                const d = document.createElement('div');
                d.innerHTML = midSVGs[midIndices[i]];
                const j = getElementJitter('mid');
                d.style.cssText = `position:absolute;left:${midPositions[i]}px;bottom:${j.y}px;transform:scale(${j.scale});opacity:${j.opacity}`;
                mid.appendChild(d);
            }
            duplicateForSeamless(mid, midBaseWidth);

            // PARK LAYER - Hyde Park / Regent's Park feel
            const parkSVGs = [
                // Oak tree
                `<svg width="45" height="65" viewBox="0 0 45 65"><rect x="19" y="42" width="7" height="23" fill="#5D4423" opacity="0.85"/><ellipse cx="22" cy="26" rx="20" ry="24" fill="#3A7A32" opacity="0.8"/><ellipse cx="16" cy="22" rx="10" ry="12" fill="#4A8A42" opacity="0.7"/><ellipse cx="30" cy="28" rx="8" ry="10" fill="#4A8A42" opacity="0.7"/></svg>`,
                // Park bench
                `<svg width="45" height="32" viewBox="0 0 45 32"><rect x="4" y="18" width="3" height="14" fill="#1A1A1A" opacity="0.75"/><rect x="38" y="18" width="3" height="14" fill="#1A1A1A" opacity="0.75"/><rect x="0" y="10" width="45" height="10" fill="#5D4E37" rx="2" opacity="0.8"/><rect x="0" y="2" width="45" height="10" fill="#6B5D4D" rx="2" opacity="0.8"/></svg>`,
                // Flower bed
                `<svg width="35" height="18" viewBox="0 0 35 18"><ellipse cx="17" cy="14" rx="16" ry="4" fill="#5A4A3A" opacity="0.6"/><circle cx="8" cy="8" r="4" fill="#FF6090" opacity="0.7"/><circle cx="17" cy="6" r="4" fill="#FFD700" opacity="0.7"/><circle cx="26" cy="8" r="4" fill="#9070FF" opacity="0.7"/><circle cx="8" cy="8" r="2" fill="#FFD700" opacity="0.6"/><circle cx="17" cy="6" r="2" fill="#FF6090" opacity="0.6"/><circle cx="26" cy="8" r="2" fill="#FFD700" opacity="0.6"/></svg>`,
                // Decorative shrub
                `<svg width="28" height="22" viewBox="0 0 28 22"><ellipse cx="14" cy="15" rx="13" ry="8" fill="#3A8A32" opacity="0.8"/><ellipse cx="10" cy="12" rx="6" ry="5" fill="#4A9A42" opacity="0.7"/><ellipse cx="18" cy="12" rx="6" ry="5" fill="#4A9A42" opacity="0.7"/></svg>`,
                // Swan on water
                `<svg width="32" height="25" viewBox="0 0 32 25"><ellipse cx="18" cy="20" rx="13" ry="5" fill="#FFFFFF" opacity="0.85"/><path d="M 8 20 Q 4 14 8 8 Q 11 5 13 9" stroke="#FFFFFF" stroke-width="4" fill="none" opacity="0.85"/><ellipse cx="6" cy="8" rx="4" ry="3" fill="#FFFFFF" opacity="0.85"/><ellipse cx="4" cy="8" rx="2" ry="1.2" fill="#FF8C00" opacity="0.8"/><circle cx="6" cy="7" r="1" fill="#111" opacity="0.8"/></svg>`,
                // Small tree
                `<svg width="30" height="50" viewBox="0 0 30 50"><rect x="12" y="32" width="6" height="18" fill="#5D4423" opacity="0.85"/><ellipse cx="15" cy="20" rx="13" ry="18" fill="#3A7A32" opacity="0.8"/><ellipse cx="11" cy="17" rx="7" ry="9" fill="#4A8A42" opacity="0.7"/></svg>`,
                // Small duck
                `<svg width="20" height="16" viewBox="0 0 20 16"><ellipse cx="12" cy="11" rx="8" ry="5" fill="#8B6914" opacity="0.8"/><circle cx="5" cy="8" r="4" fill="#8B6914" opacity="0.8"/><ellipse cx="2" cy="9" rx="2.5" ry="1.5" fill="#FF8C00" opacity="0.8"/><circle cx="5" cy="7" r="1" fill="#111" opacity="0.8"/></svg>`,
                // Ornate fountain base
                `<svg width="40" height="40" viewBox="0 0 40 40"><ellipse cx="20" cy="36" rx="18" ry="4" fill="#909090" opacity="0.7"/><rect x="16" y="20" width="8" height="16" fill="#A0A0A0" opacity="0.7"/><ellipse cx="20" cy="20" rx="8" ry="3" fill="#A0A0A0" opacity="0.7"/><ellipse cx="20" cy="12" rx="3" ry="8" fill="#88BBDD" opacity="0.4"/></svg>`
            ];
            const parkBaseWidth = window.innerWidth;
            const parkCount = isSmallScreen ? 6 : 9;
            const parkIndices = generateNonAdjacentIndices(parkCount, parkSVGs.length);
            const parkPositions = generateVariedPositions(parkCount, parkBaseWidth, 55, 60);
            for (let i = 0; i < parkCount; i++) {
                const d = document.createElement('div');
                d.innerHTML = parkSVGs[parkIndices[i]];
                const j = getElementJitter('park');
                d.style.cssText = `position:absolute;left:${parkPositions[i]}px;bottom:${j.y}px;transform:scale(${j.scale});opacity:${j.opacity}`;
                park.appendChild(d);
            }
            duplicateForSeamless(park, parkBaseWidth);
        }

        function initLives() {
            livesContainer.innerHTML = '';
            for (let i = 0; i < MAX_LIVES; i++) { // uses MAX_LIVES
                const b = document.createElement('div');
                b.className = 'life-bone';
                b.innerHTML = lifeBoneSVG;
                b.id = 'life-' + i;
                livesContainer.appendChild(b);
            }
        }

        function updateLives() {
            for (let i = 0; i < MAX_LIVES; i++) { // uses MAX_LIVES
                const b = document.getElementById('life-' + i);
                b.classList.toggle('lost', i >= lives);
            }
        }

        // Flying objects polish - map obstacle types to idle animation classes
        // ROSTER UPDATE: removed firework/hairdryer, added umbrella/frisbee
        const idleAnimations = {
            balloon: 'balloon-idle',
            pigeon: 'pigeon-idle',
            thunder: 'thunder-idle',
            vacuum: 'vacuum-idle',
            cat: 'cat-idle',
            squirrel: 'squirrel-idle',
            skateboard: 'skateboard-idle',
            umbrella: 'umbrella-idle',
            frisbee: 'frisbee-idle'
        };

        // Step 2.5 spawn pacing - PART 1: Calculate dynamic minimum spacing
        // Anti-cluster upgrade: nonlinear gameSpeed scaling for more aggressive spacing at high speeds
        // Difficulty curve: now uses tier-based multipliers for 3-act emotional arc
        function getMinSpacingPx(lastType, nextType) {
            // Get current difficulty tier
            const tier = getDifficultyTier(score);

            // Nonlinear gameSpeed scaling: spacing grows faster at higher speeds
            const speedMultiplier = Math.pow(gameSpeed, SPEED_EXPONENT);
            let spacing = BASE_REACTION_PX + (speedMultiplier * SPEED_FACTOR_PX);

            // Add width contribution from last obstacle
            if (lastType) {
                spacing += lastType.width * WIDTH_FACTOR;
            }

            // Step 2.5 spawn pacing - extra spacing for difficult combinations
            const lastIsAir = lastType && AIR_HAZARDS.includes(lastType.id);
            const nextIsAir = nextType && AIR_HAZARDS.includes(nextType.id);
            const lastIsTall = lastType && TALL_HAZARDS.includes(lastType.id);
            const nextIsTall = nextType && TALL_HAZARDS.includes(nextType.id);

            if (lastIsAir || nextIsAir) spacing += AIR_EXTRA_SPACING;
            if (lastIsTall || nextIsTall) spacing += TALL_EXTRA_SPACING;

            // Difficulty curve - apply tier-based spacing multiplier
            spacing *= getSpacingMultiplier(tier);

            // Difficulty curve - enforce minimum survivable gap (absolute floor)
            const minGap = getMinSurvivableGap(tier);
            spacing = Math.max(spacing, minGap);

            return spacing;
        }

        // Step 2.5 spawn pacing - PART 1: Get rightmost obstacle position
        function getRightmostObstacleX() {
            if (obstacles.length === 0) return -Infinity;
            return Math.max(...obstacles.map(o => o.x));
        }

        // Anti-cluster upgrade: frame counter for recovery window tracking
        let frameCount = 0;

        // Gameplay polish - Check if spawn would create impossible cluster
        // Applies hard minimum distance, recovery window spacing, and dynamic spacing rules
        function canSpawnObstacle(candidateType) {
            // Bones have their own safety check
            if (candidateType === null) return true;

            const rightmostX = getRightmostObstacleX();
			const spawnX = viewportW + 80;
            const distanceFromSpawn = spawnX - rightmostX;
            const lastObs = obstacles.length > 0 ? obstacles[obstacles.length - 1] : null;
            const lastType = lastObs ? lastObs.type : null;
            const category = AIR_HAZARDS.includes(candidateType.id) ? 'air' : 'ground';

            // Gameplay polish - Hard safety rule: never spawn if too close to spawnX
            if (distanceFromSpawn < HARD_MIN_DISTANCE) {
                if (DEBUG) console.log(`[BLOCKED] id=${candidateType.id} cat=${category} speed=${gameSpeed.toFixed(2)} min=${HARD_MIN_DISTANCE} rightX=${rightmostX.toFixed(0)} spawnX=${spawnX} reason=hard_min`);
                return false;
            }

            // Gameplay polish - Calculate base minimum spacing
            let minSpacing = getMinSpacingPx(lastType, candidateType);

            // Gameplay polish - Recovery window after tall hazards applies to ALL obstacles
            const framesSinceTall = frameCount - lastTallSpawnFrame;
            const inRecovery = lastTallSpawnFrame > 0 && framesSinceTall < TALL_RECOVERY_FRAMES;
            if (inRecovery) {
                minSpacing += RECOVERY_EXTRA_SPACING;
            }

            const canSpawn = distanceFromSpawn >= minSpacing;

            if (DEBUG && !canSpawn) {
                const recStr = inRecovery ? ` recovery=${framesSinceTall}/${TALL_RECOVERY_FRAMES}` : '';
                console.log(`[BLOCKED] id=${candidateType.id} cat=${category} speed=${gameSpeed.toFixed(2)} min=${minSpacing.toFixed(0)} rightX=${rightmostX.toFixed(0)} spawnX=${spawnX}${recStr} reason=spacing`);
            }

            return canSpawn;
        }

        // Gameplay polish - Log successful spawn (called from spawnObstacle)
        function logSpawn(candidateType) {
            if (!DEBUG) return;
            const rightmostX = getRightmostObstacleX();
			const spawnX = viewportW + 80;
            const lastObs = obstacles.length > 0 ? obstacles[obstacles.length - 1] : null;
            const lastType = lastObs ? lastObs.type : null;
            const category = AIR_HAZARDS.includes(candidateType.id) ? 'air' : 'ground';
            const minSpacing = getMinSpacingPx(lastType, candidateType);
            console.log(`[SPAWNED] id=${candidateType.id} cat=${category} speed=${gameSpeed.toFixed(2)} min=${minSpacing.toFixed(0)} rightX=${rightmostX.toFixed(0)} spawnX=${spawnX}`);
        }

        // Step 2.6 spawn gate accuracy - Get next candidate WITHOUT modifying state
        // Returns: obstacle type object, or null for "spawn bone", or undefined if pattern queue empty
        function peekPatternCandidate() {
            if (patternQueue.length === 0) return undefined;
            const patternType = patternQueue[0]; // Peek, don't shift
            if (patternType === 'bone') return null;
            return scaryThings.find(t => t.id === patternType) || undefined;
        }

        // Step 2.6 spawn gate accuracy - Select obstacle based on fairness rules (no pattern queue)
        // Difficulty curve: now uses tier-based hazard probabilities
        function selectRandomFairObstacle() {
            const now = Date.now();
            const tier = getDifficultyTier(score);
            let candidates = [...scaryThings];

            // Difficulty curve - get tier-specific hazard chances
            let airChance, tallChance;
            switch (tier) {
                case 'EARLY':
                    airChance = AIR_HAZARD_CHANCE_EARLY;
                    tallChance = TALL_HAZARD_CHANCE_EARLY;
                    break;
                case 'MID':
                    airChance = AIR_HAZARD_CHANCE_MID;
                    tallChance = TALL_HAZARD_CHANCE_MID;
                    break;
                case 'LATE':
                    airChance = AIR_HAZARD_CHANCE_LATE;
                    tallChance = TALL_HAZARD_CHANCE_LATE;
                    break;
                default:
                    airChance = AIR_HAZARD_CHANCE_MID;
                    tallChance = TALL_HAZARD_CHANCE_MID;
            }

            // Difficulty curve - post-hard-hazard: prefer small hazards
            const timeSinceHard = now - lastHardHazardTime;
            const inPostHardWindow = lastHardHazardTime > 0 && timeSinceHard < 1500;
            if (inPostHardWindow && Math.random() < POST_HARD_SMALL_ONLY_CHANCE) {
                const smallOnly = candidates.filter(t => SMALL_HAZARDS.includes(t.id));
                if (smallOnly.length > 0) {
                    if (DEBUG_DIFFICULTY) console.log('[DIFFICULTY] Post-hard breather: forcing small hazard');
                    candidates = smallOnly;
                }
            }

            // Step 2.5 spawn pacing - PART 2: Never two air hazards back-to-back
            if (lastSpawnedCategory === 'air') {
                candidates = candidates.filter(t => !AIR_HAZARDS.includes(t.id));
            }

            // Step 2.5 spawn pacing - filter out air hazards if cooldown hasn't passed
            if (now - lastAirSpawnTime < AIR_COOLDOWN) {
                candidates = candidates.filter(t => !AIR_HAZARDS.includes(t.id));
            }

            // Step 2.5 spawn pacing - filter out tall hazards if cooldown hasn't passed
            if (now - lastTallSpawnTime < TALL_COOLDOWN) {
                candidates = candidates.filter(t => !TALL_HAZARDS.includes(t.id));
            }

            // Step 2.5 spawn pacing - avoid same type twice in a row
            if (lastSpawnedType && candidates.length > 1) {
                candidates = candidates.filter(t => t.id !== lastSpawnedType);
            }

            // Step 2.5 spawn pacing - prefer variety: if last was tall, prefer small
            if (TALL_HAZARDS.includes(lastSpawnedType) && candidates.length > 2) {
                const smallCandidates = candidates.filter(t => SMALL_HAZARDS.includes(t.id));
                if (smallCandidates.length > 0 && Math.random() < 0.7) {
                    candidates = smallCandidates;
                }
            }

            // Fallback to full list if too filtered
            if (candidates.length === 0) candidates = [...scaryThings];

            // Difficulty curve - tier-based hazard type weighting
            // Separate candidates into categories and apply weighted selection
            const airCandidates = candidates.filter(t => AIR_HAZARDS.includes(t.id));
            const tallCandidates = candidates.filter(t => TALL_HAZARDS.includes(t.id) && !AIR_HAZARDS.includes(t.id));
            const smallCandidates = candidates.filter(t => SMALL_HAZARDS.includes(t.id));
            const otherCandidates = candidates.filter(t =>
                !AIR_HAZARDS.includes(t.id) && !TALL_HAZARDS.includes(t.id) && !SMALL_HAZARDS.includes(t.id)
            );

            // Weighted random selection based on tier probabilities
            const roll = Math.random();
            let selectedPool;

            if (roll < airChance && airCandidates.length > 0) {
                selectedPool = airCandidates;
            } else if (roll < airChance + tallChance && tallCandidates.length > 0) {
                selectedPool = tallCandidates;
            } else if (smallCandidates.length > 0) {
                // Prefer small hazards for remaining probability
                selectedPool = smallCandidates;
            } else {
                // Fallback to any remaining candidates
                selectedPool = candidates;
            }

            return selectedPool[Math.floor(Math.random() * selectedPool.length)];
        }

        // Step 2.6 spawn gate accuracy - Unified candidate selection
        // Returns obstacle type object or null (for bone)
        // This is called once per spawn attempt and used for both gating AND spawning
        let cachedNextCandidate = null;
        let candidateCacheValid = false;

        function getNextObstacleCandidate() {
            // Step 2.6 spawn gate accuracy - Return cached candidate if valid
            if (candidateCacheValid) return cachedNextCandidate;

            // Step 2.6 spawn gate accuracy - Check pattern queue first
            const patternCandidate = peekPatternCandidate();
            if (patternCandidate !== undefined) {
                cachedNextCandidate = patternCandidate; // Could be obstacle type or null (bone)
                candidateCacheValid = true;
                return cachedNextCandidate;
            }

            // Step 2.6 spawn gate accuracy - No pattern, use fair random selection
            cachedNextCandidate = selectRandomFairObstacle();
            candidateCacheValid = true;
            return cachedNextCandidate;
        }

        // Step 2.6 spawn gate accuracy - Invalidate cache after spawn or each frame
        function invalidateCandidateCache() {
            candidateCacheValid = false;
            cachedNextCandidate = null;
        }

        // Step 2.5 spawn pacing - PART 2: Generate rhythm pattern at milestones
        function maybeQueuePattern() {
            // Only trigger at score milestones and if queue is empty
            if (patternQueue.length > 0) return;
            if (score > 0 && score % PATTERN_SCORE_INTERVAL < 15 && Math.random() < 0.4) {
                // Pattern: ground -> ground -> air -> (optional bone)
                const groundOptions = SMALL_HAZARDS.filter(id => id !== lastSpawnedType);
                const g1 = groundOptions[Math.floor(Math.random() * groundOptions.length)] || 'pigeon';
                const g2 = groundOptions.filter(id => id !== g1)[Math.floor(Math.random() * (groundOptions.length - 1))] || 'squirrel';
                const airOptions = AIR_HAZARDS;
                const a1 = airOptions[Math.floor(Math.random() * airOptions.length)];

                patternQueue.push(g1, g2, a1);
                if (Math.random() < 0.5) patternQueue.push('bone');
                // Step 2.6 spawn gate accuracy - invalidate cache when pattern queued
                invalidateCandidateCache();
            }
        }

        // Step 2.6 spawn gate accuracy - Consume pattern queue item (only call when actually spawning)
        function consumePatternQueueItem() {
            if (patternQueue.length > 0) {
                patternQueue.shift();
            }
        }

        // Step 2.6 spawn gate accuracy - spawnObstacle now accepts type parameter
        function spawnObstacle(t) {
            // Step 2.6 spawn gate accuracy - if null passed, spawn bone instead (pattern request)
            if (t === null) {
                consumePatternQueueItem();
                spawnPowerup();
                invalidateCandidateCache();
                return;
            }

            const now = Date.now();

            // Step 2.6 spawn gate accuracy - update tracking correctly
            if (AIR_HAZARDS.includes(t.id)) {
                lastAirSpawnTime = now;
                lastSpawnedCategory = 'air';
            } else {
                lastSpawnedCategory = 'ground';
            }
            if (TALL_HAZARDS.includes(t.id)) {
                lastTallSpawnTime = now;
                lastTallSpawnFrame = frameCount; // Anti-cluster: track frame for recovery window
            }
            lastSpawnedType = t.id;
            consecutiveSpawns++;

            // Gameplay polish - log spawn decision when DEBUG is enabled
            logSpawn(t);

            // Step 2.6 spawn gate accuracy - consume pattern queue if this was a pattern spawn
            consumePatternQueueItem();

            const o = document.createElement('div');
            o.className = 'obstacle';

            // Flying objects polish - wrap SVG in sprite div for animations (preserves hitbox)
            const sprite = document.createElement('div');
            const idleClass = idleAnimations[t.id] || 'default-idle';
            // CHANGE (spawn-ease): Don't apply .spawning immediately; apply on viewport entry at high speed
            sprite.className = 'sprite';
            sprite.innerHTML = t.svg;
            o.appendChild(sprite);

            // CHANGE (visual): use transform for smoother movement - set right:0 as anchor
            // Set initial transform immediately to prevent one-frame flash at wrong position
            // Mobile UX: Add baseline offset so obstacles lift with the gameplay band
            const obstacleBottomY = t.groundY + getMobileBaselineOffset();
            o.style.cssText = `width:${t.width}px;height:${t.height}px;right:0;bottom:${obstacleBottomY}%;will-change:transform;transform:translate3d(80px,0,0)`;
            obstaclesContainer.appendChild(o);

            // CHANGE (spawn-ease): Determine eligibility for viewport-entry easing (high speed only)
            // All entry animation logic is handled in updateObstacles() as single source of truth
            const reduceMotion = body.classList.contains('reduce-motion');
            const spawnEaseEligible = score >= 1000 && !reduceMotion;

            // If eligible for spawn easing, add spawn-pending to hold invisible state until viewport entry
            if (spawnEaseEligible) {
                sprite.classList.add('spawn-pending');
            }

            obstacles.push({
                element: o,
				x: viewportW + 80,
                type: t,
                hit: false,
                _sprite: sprite,
                _spawnEaseEligible: spawnEaseEligible,
                _spawnEaseDone: false,
                _idleClass: idleClass
            });

            // Step 2.6 spawn gate accuracy - invalidate cache after spawning
            invalidateCandidateCache();
        }

        // Step 2.7 powerup safety - Check if bone spawn position is safe
        function isBonePositionSafe(boneHeight) {
            const boneSpawnX = viewportW + 200;
            // Step 2.7 powerup safety - tuned safe distances
            const safeDistanceBehind = 120; // Don't spawn too close behind obstacle
            const safeDistanceAhead = 280;  // Don't spawn if obstacle will overlap soon

            for (const o of obstacles) {
                // Step 2.7 powerup safety - check if obstacle is too close behind spawn point
                if (o.x > boneSpawnX - safeDistanceBehind && o.x < boneSpawnX + 60) {
                    return false;
                }
                // Step 2.7 powerup safety - check if obstacle will reach bone's position while bone is still there
                if (o.x > boneSpawnX && o.x < boneSpawnX + safeDistanceAhead) {
                    // Check vertical overlap potential
                    const obsBottomPct = o.type.groundY;
                    const obsTopPct = obsBottomPct + (o.type.height / window.innerHeight) * 100;
                    // Bone heights are 18, 25, 32 percent - use 6% margin for safety
                    if (boneHeight >= obsBottomPct - 6 && boneHeight <= obsTopPct + 6) {
                        return false;
                    }
                }
            }
            return true;
        }

        // ========================================================================
        // POWERUP SPAWN TUNING (single source of truth)
        // Bone spawn chance decreases with score for mid-run tension.
        // CHANGE (cleanup): removed duplicate legacy blocks; single source of truth
        // ========================================================================

        // Step 2.7 powerup safety - available bone heights
        const BONE_HEIGHTS = [18, 25, 32];

        // Bone spawn scales down with score - tuned for mid-run tension (~250-400)
        // Returns spawn chance (0-1) and cooldown multiplier based on current score
        function getBoneSpawnChance(currentScore) {
            // Early game (< 150): generous bones to help learning
            if (currentScore < 150) {
                return { chance: 1.0, cooldownMult: 1.0 };
            }
            // CHANGE (difficulty): tighten bone scarcity curve (one notch) - was 0.80/1.20
            // Mid-early (150-300): reduced ~12% for mid-run tension
            if (currentScore < 300) {
                return { chance: 0.70, cooldownMult: 1.30 };
            }
            // CHANGE (difficulty): tighten bone scarcity curve (one notch) - was 0.55/1.40
            // Mid game (300-450): reduced ~10% for sustained tension
            if (currentScore < 450) {
                return { chance: 0.50, cooldownMult: 1.55 };
            }
            // Late game (> 450): notably reduced (unchanged from previous tightening)
            return { chance: 0.30, cooldownMult: 1.80 };
        }

        // Priority 3 Difficulty Lever 1: Spawn interval multiplier
        // Increases spawn frequency mid-to-late run without changing spacing gates.
        // canSpawnObstacle() remains authoritative for survivable gapsâ€”this only
        // reduces the TIME between spawn attempts, adding decision pressure
        // without demanding faster reactions.
        function getSpawnIntervalMultiplier(currentScore) {
            // Spawn frequency safety clamp: protect early game and set hard floor
            const EARLY_GAME_CAP = 800;  // No acceleration before this score
            const HARD_FLOOR = 0.85;     // Never go below 15% faster than base

            if (currentScore < EARLY_GAME_CAP) return 1.0; // Early game: no spawn acceleration

            if (currentScore < 1400) {
                // Linear ramp: 1.0 at 800 â†’ 0.90 at 1400
                const t = (currentScore - EARLY_GAME_CAP) / 600;
                return Math.max(HARD_FLOOR, 1.0 - (t * 0.10));
            }
            return HARD_FLOOR;                             // Cap at 15% more frequent
        }

        // Step 2.7 powerup safety - find a safe height for bone spawn
        // Priority 2: "Temptation bias" adds decision pressure without changing obstacle fairness.
        // After score >= 450, 30% of bones prefer heights that create hesitation:
        // - Ground hazard coming â†’ bone biased higher (tempts a jump)
        // - Air hazard coming â†’ bone biased lower (tempts staying grounded)
        function findSafeBoneHeight() {
			const boneSpawnX = viewportW + 200;
            const safeDistanceAhead = 280; // Same as isBonePositionSafe

            // Safety check: is any obstacle within the danger window?
            // If so, skip temptation bias entirely to avoid unfair setups
            const obstacleNearby = obstacles.some(o =>
                o.x > boneSpawnX - 120 && o.x < boneSpawnX + safeDistanceAhead
            );

            // Apply temptation bias only after mid-game, with no nearby obstacles, 30% of the time
            const applyBias = score >= 450 && !obstacleNearby && Math.random() < 0.30;

            if (applyBias) {
                const nextCandidate = getNextObstacleCandidate();
                if (nextCandidate) {
                    const isAirHazard = AIR_HAZARDS.includes(nextCandidate.id);
                    // Bias order: air hazard â†’ prefer low; ground hazard â†’ prefer high
                    const biasedOrder = isAirHazard
                        ? [18, 25, 32]  // Low first (stay grounded temptation)
                        : [32, 25, 18]; // High first (jump temptation)

                    for (const height of biasedOrder) {
                        if (isBonePositionSafe(height)) {
                            boneBiasLastApplied = true; // Debug HUD tracking
                            return height;
                        }
                    }
                }
            }

            // Default: random safe selection (70% of time, or fallback)
            for (let attempt = 0; attempt < 5; attempt++) {
                const candidateHeight = BONE_HEIGHTS[Math.floor(Math.random() * BONE_HEIGHTS.length)];
                if (isBonePositionSafe(candidateHeight)) {
                    return candidateHeight;
                }
            }
            return null; // No safe height found after 5 attempts
        }

        // Step 2.7 powerup safety - spawnPowerup accepts optional height parameter
        function spawnPowerup(preChosenHeight) {
            // Step 2.7 powerup safety - use pre-chosen height or find one
            let chosenHeight = preChosenHeight;
            if (chosenHeight === undefined) {
                // Fallback: find safe height internally (backwards compatibility)
                chosenHeight = findSafeBoneHeight();
            }

            // Step 2.7 powerup safety - skip spawn if no safe position
            if (chosenHeight === null) return false;

            const p = document.createElement('div');
            p.className = 'powerup';

            // Flying objects polish - wrap SVG in sprite div for animations (preserves hitbox)
            // Powerups start with 'sprite' only - no spawn animation, appear immediately
            const sprite = document.createElement('div');
            sprite.className = 'sprite';
            sprite.innerHTML = boneSVG;
            p.appendChild(sprite);

            // CHANGE (visual): use transform for smoother movement - set right:0 as anchor
            // Set initial transform immediately to prevent one-frame flash at wrong position
            // Mobile UX: Add baseline offset so bones lift with the gameplay band
            const boneBottomY = chosenHeight + getMobileBaselineOffset();
            p.style.cssText = `width:45px;height:26px;right:0;bottom:${boneBottomY}%;will-change:transform;transform:translate3d(200px,0,0)`;
            obstaclesContainer.appendChild(p);

			powerups.push({ element: p, x: viewportW + 200, collected: false, height: chosenHeight });
            return true; // Step 2.7 powerup safety - indicate successful spawn
        }

        // ========================================================================
        // MOTION SMOOTHING PASS (2026-01-22)
        // - GPU-accelerated movement via translate3d (not style.right)
        // - will-change: transform set on spawn (lines 3277, 3380)
        // - Substep collision checks at high speed for accuracy
        //
        // SANITY CHECK: Smoother motion can make the game FEEL harder because:
        // 1. Players see obstacles more clearly (less motion blur/strobing)
        // 2. Collision feedback is more precise (no "I dodged that!" frustration)
        // 3. High-speed sections appear faster/more intense visually
        // This is a PERCEIVED difficulty increase, not a mechanical one.
        // No spawn rates, physics, or scoring were changed.
        // ========================================================================

        // CHANGE (visual): high-speed substep motion smoothing to reduce strobing
        // When spd > 10, split movement into substeps for smoother collision and visual continuity
        		// VIEWPORT WIDTH STABILIZATION (iOS)
		// Avoid using live window.innerWidth for obstacle transforms because iOS can change it mid-run
		// when the browser UI collapses/expands, causing a visible "hop".
		let viewportW = Math.round((window.visualViewport && window.visualViewport.width) || document.documentElement.clientWidth || window.innerWidth);

		function refreshViewportW() {
			viewportW = Math.round((window.visualViewport && window.visualViewport.width) || document.documentElement.clientWidth || window.innerWidth);
		}

		window.addEventListener('resize', refreshViewportW, { passive: true });
		if (window.visualViewport) window.visualViewport.addEventListener('resize', refreshViewportW, { passive: true });
        		// Viewport width helper: on iOS, visualViewport avoids jumps when browser UI shows/hides
        const SUBSTEP_THRESHOLD = 10;  // px/frame threshold to enable substeps
        const MAX_SUBSTEPS = 1; // v1.1 perf: disable substeps (avoid layout thrash);        // cap to avoid performance issues

        function updateObstacles(dtScale = 1) {
            const spd = 5 * gameSpeed;
            const tr = taterContainer.getBoundingClientRect();
            perfRectReads++;
            const hb = { left: tr.left + 20, right: tr.right - 15, top: tr.top + 15, bottom: tr.bottom - 12 };

            // Broad-phase proximity threshold: only call getBoundingClientRect when
            // obstacle is within this distance of Tater (avoids layout thrash on mobile)
            const proximityThreshold = tr.right + 250;

            // Calculate substeps: 1 step if slow, up to MAX_SUBSTEPS if fast
            const numSteps = spd > SUBSTEP_THRESHOLD ? Math.min(MAX_SUBSTEPS, Math.ceil(spd / SUBSTEP_THRESHOLD)) : 1;
            const stepSize = (spd * dtScale) / numSteps;

            obstacles = obstacles.filter(o => {
                // Position update (substeps disabled: MAX_SUBSTEPS=1)
                for (let step = 0; step < numSteps; step++) {
                    o.x -= stepSize;
                }
                // Single transform write per frame (eliminates layout thrash)
                const oTx = o.x - viewportW;
                o.element.style.transform = `translate3d(${oTx}px, 0, 0)`;
                // Collision check AFTER transform is set (getBoundingClientRect reads final position)
                // Broad-phase gate: skip expensive getBoundingClientRect if obstacle is far from Tater
                if (!o.hit && !invulnerable && o.x < proximityThreshold) {
                    const or = o.element.getBoundingClientRect();
                    perfRectReads++;
                    if (hb.left < or.right - 8 && hb.right > or.left + 8 && hb.top < or.bottom - 8 && hb.bottom > or.top + 8) {
                        o.hit = true;
                        takeDamage();
                    }
                }
                // CHANGE (spawn-ease): Single source of truth for entry animation when obstacle enters viewport
                if (!o._spawnEaseDone && o.x <= viewportW + 40) {
                    o._spawnEaseDone = true;
                    if (o._spawnEaseEligible) {
                        // High speed: Apply soft spawn-in easing, then go directly to idle (skip telegraph)
                        // Add 'spawning' BEFORE removing 'spawn-pending' to prevent one-frame flash
                        o._sprite.classList.add('spawning');
                        o._sprite.classList.remove('spawn-pending');
                        o._sprite.addEventListener('animationend', function onSpawnEnd() {
                            o._sprite.classList.remove('spawning');
                            if (!o._sprite.classList.contains(o._idleClass)) {
                                o._sprite.classList.add(o._idleClass);
                            }
                        }, { once: true });
                    } else {
                        // Normal speed: telegraph -> idle sequence (no spawn-ease animation)
                        o._sprite.classList.add('telegraph');
                        o._sprite.addEventListener('animationend', function onTelegraphEnd() {
                            o._sprite.classList.remove('telegraph');
                            if (!o._sprite.classList.contains(o._idleClass)) {
                                o._sprite.classList.add(o._idleClass);
                            }
                        }, { once: true });
                    }
                }
                if (!o.scored && o.x < tr.left - 40) {
                    o.scored = true;
                    score += Math.floor(10 * gameSpeed);
                    scoreDisplay.textContent = score;
                    updateJourneyDisplay(score); // Journey framing
                    updateTaterTiredState(score); // Priority 3: Emotional feedback
                }
                if (o.x < -100) { o.element.remove(); return false; }
                return true;
            });

            powerups = powerups.filter(p => {
                // Position update (substeps disabled: MAX_SUBSTEPS=1)
                for (let step = 0; step < numSteps; step++) {
                    p.x -= stepSize;
                }
                // Single transform write per frame (eliminates layout thrash)
                const pTx = p.x - viewportW;
                p.element.style.transform = `translate3d(${pTx}px, 0, 0)`;
                // Collision check AFTER transform is set (getBoundingClientRect reads final position)
                // Broad-phase gate: skip expensive getBoundingClientRect if powerup is far from Tater
                if (!p.collected && p.x < proximityThreshold) {
                    const pr = p.element.getBoundingClientRect();
                    perfRectReads++;
                    if (hb.left < pr.right && hb.right > pr.left && hb.top < pr.bottom && hb.bottom > pr.top) {
                        p.collected = true;
                        collectPowerup(p);
                    }
                }
                if (p.x < -50) { p.element.remove(); return false; }
                return true;
            });
        }

        function collectPowerup(p) {
            // Step 3 juice - bone pop animation before removal
            const sprite = p.element.querySelector('.sprite');
            if (sprite) sprite.classList.add('collected');

            // Step 3 sound - play collect sound
            playHealOrCollect();

            if (lives < MAX_LIVES) { // uses MAX_LIVES
                lives++;
                updateLives();
                healFlash.classList.add('show');
                setTimeout(() => healFlash.classList.remove('show'), 180);
                tater.classList.remove('running');
                tater.classList.add('healed');
                setTimeout(() => { tater.classList.remove('healed'); if (!isJumping && !isGameOver) tater.classList.add('running'); }, 500);

                // Step 3 juice - floating "+1" text near Tater
                const tr = taterContainer.getBoundingClientRect();
                showFloatText('+1', tr.left + tr.width / 2, tr.top - 10);
            }
            score += 20;
            scoreDisplay.textContent = score;
            updateJourneyDisplay(score); // Journey framing
            updateTaterTiredState(score); // Priority 3: Emotional feedback

            // Onboarding - show first bone collected toast
            if (!toastShownBone) {
                toastShownBone = true;
                safeSet('taterToastBone', 'true');
                setTimeout(() => showToast('Bones heal you ðŸ¦´', 2000), 300);
            }

            // Remove element after pop animation completes
            setTimeout(() => p.element.remove(), 150);
        }

        function takeDamage() {
            lives--;
            updateLives();

            // Step 3 sound - play hit sound
            playHit();

            // Step 3 juice - screen shake
            gameContainer.classList.add('shake');
            setTimeout(() => gameContainer.classList.remove('shake'), 100);

            // Step 3 juice - hit-stop (100ms pause of game updates)
            hitStopUntil = Date.now() + 100;

            damageFlash.classList.add('show');
            setTimeout(() => damageFlash.classList.remove('show'), 120);
            tater.classList.remove('running');
            tater.classList.add('hurt');
            setTimeout(() => { tater.classList.remove('hurt'); if (!isGameOver && !isJumping) tater.classList.add('running'); }, 500);
            invulnerable = true;
            setTimeout(() => invulnerable = false, 1000);
            if (lives <= 0) gameOver();
        }

        // Step 1.1 fix: Always set isHolding so releaseJump can run and buffer jumps while airborne
        function startJump() {
            // Step 4 tutorial - don't start jump while tutorial is active
            if (isPaused || isGameOver || tutorialActive) return;
            startPrompt.classList.remove('show');
            hideHintBar(); // v1.1.x safety: never let bottom hint pill stick
            // Visual hierarchy & pacing - Part B: First input starts the run
            if (preRunState) {
                preRunState = false;
                if (DEBUG_START) console.log('[DEBUG] preRunState -> false, starting run');
                startPrompt.classList.remove('show');
                // Onboarding - hide hint bar when run begins (Mode B: no persistent hint during play)
                hideHintBar();
                body.classList.add('playing'); // Visual hierarchy & pacing - Part A
                tater.classList.add('running');
                pauseAnimations(false);
                startAmbientRamp(); // CHANGE (ambient-ramp): Begin gentle ramp from 0.55 to 1.0
            }
            isHolding = true;
            jumpPower = 0;
        }
        // Step 1.1 fix: Only charge jumpPower when grounded or in coyote time, preserving hold-to-charge mechanic
        function updateJumpCharge() {
            if (!isHolding) return;
            const now = Date.now();
            const canCharge = !isJumping || (now - lastGroundedTime < COYOTE_TIME);
            if (canCharge) {
                jumpPower = Math.min(jumpPower + 4, 100);
                jumpIndicator.style.height = (jumpPower * 0.6) + 'px';
            }
        }
        // Step 1.1 fix: Remove jumpPower > 5 check so short taps use MIN_JUMP_VELOCITY
        // Step 1.1 fix: Always record buffer time when releasing while airborne
        function releaseJump() {
            if (!isHolding) return;
            isHolding = false;
            const now = Date.now();

            // Check if we can jump now (on ground or within coyote time)
            const canJumpNow = !isJumping || (now - lastGroundedTime < COYOTE_TIME);

            if (canJumpNow) {
                // Execute jump immediately with charged velocity or minimum for short taps
                isJumping = true;
                const chargedVelocity = (jumpPower / 100) * 160 / 12;
                velocity = Math.max(MIN_JUMP_VELOCITY, chargedVelocity);
                tater.classList.remove('running');
                // Step 3 sound - play jump sound
                playJump();
                // Onboarding - show first jump toast (delayed to not interrupt)
                if (!toastShownJump) {
                    toastShownJump = true;
                    safeSet('taterToastJump', 'true');
                    setTimeout(() => showToast('Nice! Hold longer to jump higher', 2500), 800);
                }
            } else {
                // Step 1.1 fix: Buffer the jump for when we land (works for both holds and taps while airborne)
                jumpBufferTime = now;
            }

            jumpPower = 0;
            jumpIndicator.style.height = '0px';
        }

        // Jump feel improvement - asymmetric gravity creates satisfying arc (floaty peak, snappy fall)
        function updatePhysics() {
            const now = Date.now();

            if (isJumping) {
                // Apply asymmetric gravity: gentler while rising, stronger while falling
                // This creates an ease-out feel on ascent and snappier descent
                const gravity = velocity > 0 ? GRAVITY_UP : GRAVITY_DOWN;
                velocity -= gravity;

                taterY += velocity;

                if (taterY <= 0) {
                    // Landing - record grounded time and check for buffered jump
                    taterY = 0;
                    velocity = 0;
                    isJumping = false;
                    lastGroundedTime = now;

                    // Step 3 sound - play land sound
                    playLand();

                    // Jump buffering: if player released jump just before landing, execute it now
                    if (now - jumpBufferTime < JUMP_BUFFER_TIME) {
                        isJumping = true;
                        velocity = MIN_JUMP_VELOCITY; // Use minimum for buffered jumps
                        jumpBufferTime = 0; // Clear the buffer
                        // Step 3 sound - play jump sound for buffered jump
                        playJump();
                    } else if (!isPaused && !isGameOver) {
                        tater.classList.add('running');
                    }
                }

                taterContainer.style.bottom = (baseY + (taterY / window.innerHeight) * 100) + '%';
                const s = Math.max(0.3, 1 - (taterY / 150));
                shadow.style.transform = `scale(${s})`;
                shadow.style.opacity = s * 0.3;
            } else {
                // On ground - keep tracking grounded time for coyote time
                lastGroundedTime = now;
                // Ship fix: Enforce grounded position every frame to prevent visual float on mobile
                taterY = 0;
                taterContainer.style.bottom = baseY + '%';
                shadow.style.transform = 'scale(1)';
                shadow.style.opacity = 0.3;
            }
        }

        // Journey framing v2 - Game-over message based on current location index
        // Uses currentJourneyStageIndex: 0 = Hyde Park (first location), >= 1 = later locations
        function getGameOverMessage(finalScore) {
            if (currentJourneyStageIndex === 0) {
                return "Still lost, but learning the city.";
            }
            return "He's starting to find his way.";
        }

        // Game-over polish - Part D: Best score management
        // Journey framing - simplified to just manage localStorage (UI handled by updateGameOverJourney)
        function updateBestScore(currentScore) {
            const storedBest = parseInt(safeGet('taterBestScore') || '0', 10);
            const isNewBest = currentScore > storedBest;
            if (isNewBest) {
                safeSet('taterBestScore', currentScore.toString());
            }
            return isNewBest;
        }

        // Game-over polish - Enhanced game over with cinematic effects
        function gameOver() {
            isGameOver = true;
            body.classList.remove('playing'); // Visual hierarchy & pacing - restore UI

            // Game-over polish - Part C: Tater's defeated reaction
            tater.classList.remove('running', 'hurt');
            tater.classList.add('defeated');

            // Game-over polish - Part B: Cinematic framing
            gameContainer.classList.add('defeat-cinematic');
            vignetteOverlay.classList.add('show');

            // Game-over polish - Part D: Update score and message
            finalScoreDisplay.textContent = score;
            gameOverMessage.textContent = getGameOverMessage(score);
            // CHANGE (story): home clarity â€” softer title when player reached final stage
            gameOverTitle.textContent = score >= 1900 ? 'Home' : 'Oh no!';
            updateBestScore(score);
            updateGameOverJourney(score); // Journey framing - update journey display

            // Journey framing - hide milestone banner if showing
            if (milestoneBannerTimeout) {
                clearTimeout(milestoneBannerTimeout);
                milestoneBannerTimeout = null;
            }
            milestoneBanner.classList.remove('show');

            playGameOver();

            // Game-over polish - Part A: Brief defeat beat before showing overlay
            const reduceMotion = body.classList.contains('reduce-motion');
            const delay = reduceMotion ? 100 : 300;
            setTimeout(() => {
                gameOverOverlay.classList.add('show');
                pauseAnimations(true);

                // Priority 3: Emotional feedback - Hopeful beat after overlay appears
                // Subtle lift implying "we'll try again" - skip if reduce-motion
                if (!reduceMotion) {
                    taterHopefulTimeout = setTimeout(() => {
                        tater.classList.add('hopeful');
                    }, 600);
                }
            }, delay);
        }
        // Mobile UI - updated to preserve icon/label spans
        // Visual hierarchy & pacing - Part A: toggle playing class when pausing
        function togglePause() { if (isGameOver || preRunState) return; isPaused = !isPaused; pauseOverlay.classList.toggle('show', isPaused); pauseAnimations(isPaused); body.classList.toggle('playing', !isPaused); const pauseBtn = document.getElementById('pauseBtn'); const icon = isPaused ? 'â–¶' : 'â¸'; const label = isPaused ? 'Resume' : 'Pause'; pauseBtn.innerHTML = `<span class="btn-icon">${icon}</span><span class="btn-label">${label}</span>`; }

        // Auto-pause on focus loss - only pause, never auto-resume
        function forcePause() {
            // Only act if game is actively playing
            if (isGameOver || preRunState || tutorialActive || isPaused) return;
            isPaused = true;
            pauseOverlay.classList.add('show');
            pauseAnimations(true);
            body.classList.remove('playing');
            const pauseBtn = document.getElementById('pauseBtn');
            pauseBtn.innerHTML = `<span class="btn-icon">â–¶</span><span class="btn-label">Resume</span>`;
        }

        // Visual hierarchy & pacing - Part B: also check preRunState before adding running class
        function pauseAnimations(p) { document.querySelectorAll('.clouds,.landmarks-far,.landmarks-mid,.park-elements,.path').forEach(e => e.classList.toggle('paused', p)); if (p) { tater.classList.remove('running'); pauseAmbientRamp(); } else { if (!isJumping && !isGameOver && !preRunState) tater.classList.add('running'); resumeAmbientRamp(); } }

        // Step 4 tutorial - show tutorial on first run
        // CHANGE (cleanup): Priority 2A â€” remove body.playing while tutorial is open
        function showTutorial() {
            if (tutorialActive) {
                body.classList.remove('playing');
                tutorialOverlay.classList.add('show');
                pauseAnimations(true);
            }
        }

        // Step 4 tutorial - dismiss tutorial and start game
        // CHANGE (cleanup): Priority 2A â€” only restore body.playing if game is actually running
        // CHANGE (cleanup): Respect prior pause state when dismissing Help (not first-run tutorial)
        function dismissTutorial() {
            const wasFirstRunTutorial = tutorialActive; // True only on first-run, false for Help reopen
            tutorialActive = false;
            safeSet('taterTutorialSeen', 'true');
            tutorialOverlay.classList.remove('show');

            // Determine if we should unpause
            const shouldUnpause = wasFirstRunTutorial || !helpWasPausedBefore;

            if (preRunState) {
                // Hint bar stays hidden (toast-only); just show start prompt
                startPrompt.classList.add('show');
                isPaused = false;
                pauseAnimations(false);
            } else if (shouldUnpause) {
                hideHintBar();
                isPaused = false;
                pauseAnimations(false);
                if (!isGameOver) {
                    body.classList.add('playing');
                }
            }
            // If game was paused before Help, keep it paused (isPaused stays true, animations stay paused)
        }

        // UI polish - show help (tutorial) without re-enabling hint
        // CHANGE (cleanup): Priority 2A â€” remove body.playing while help overlay is open
        let helpWasPausedBefore = false; // Track if game was paused before Help opened
        function showHelp() {
            settingsOverlay.classList.remove('show'); // Close settings first
            helpWasPausedBefore = isPaused; // Save pause state before opening
            isPaused = true; // Pause game logic while help is showing
            body.classList.remove('playing'); // Priority 2A: no dimmed UI while overlay open
            startPrompt.classList.remove('show'); // Visual hierarchy & pacing - hide prompt during help
            tutorialOverlay.classList.add('show');
            pauseAnimations(true);
        }

        function resetGame() {
            // RAF chain hardening: cancel any pending frame and reset loop state
            if (gameLoopId !== null) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            gameLoopRunning = false;
            // Reset dtScale state to avoid stale jump after restart
            lastFrameTime = null;
            dtScaleSmoothed = 1;

            score = 0; lives = MAX_LIVES; gameSpeed = 1; isGameOver = false; isPaused = false; isJumping = false; isHolding = false; jumpPower = 0; velocity = 0; taterY = 0; invulnerable = false; // uses MAX_LIVES
            hitStopUntil = 0; // Ship-hardening: clear any pending hit-stop
            // Visual hierarchy & pacing - Part B: Reset to pre-run state
            preRunState = true;
            body.classList.remove('playing');
            startPrompt.classList.add('show');
            // Hint bar stays hidden (toast-only surface)
            hideHintBar();
            // CHANGE (emotion): clear all Tater mood classes on restart (uses TATER_MOOD_CLASSES)
            resetTaterEmotionalState();
            // Game-over polish - Clear cinematic effects
            gameContainer.classList.remove('defeat-cinematic');
            vignetteOverlay.classList.remove('show');
			damageFlash.classList.remove('show');
			healFlash.classList.remove('show');
            // Step 2.6 spawn gate accuracy - reset spawn tracking
            lastAirSpawnTime = 0; lastTallSpawnTime = 0; consecutiveSpawns = 0; lastSpawnedType = null; lastSpawnedCategory = null; patternQueue = [];
            // Ship-hardening: reset spawn timers to prevent desync on restart
            lastSpawnTime = 0; lastPowerupTime = 0; frameCount = 0; lastTallSpawnFrame = 0;
            // Difficulty curve - reset hard hazard tracking
            lastHardHazardTime = 0; lastLoggedTier = null;
            invalidateCandidateCache(); // Step 2.6 spawn gate accuracy
            scoreDisplay.textContent = '0'; updateLives();
            resetJourneyState(); // Journey framing - reset location display and milestone tracking
            resetAmbientRamp(); // CHANGE (ambient-ramp): Reset to calm speed for pre-run (no sprint)
            resetHighSpeedVisual(); // CHANGE (high-speed-visual): Remove high-speed class on reset
            obstacles.forEach(o => o.element.remove()); obstacles = [];
            powerups.forEach(p => p.element.remove()); powerups = [];
            pauseOverlay.classList.remove('show'); gameOverOverlay.classList.remove('show');
            // Mobile UI - reset pause button with icon/label spans
            document.getElementById('pauseBtn').innerHTML = '<span class="btn-icon">â¸</span><span class="btn-label">Pause</span>';
            jumpIndicator.style.height = '0px'; 
            applyBaseYToTater(true);
            shadow.style.transform = 'scale(1)'; shadow.style.opacity = '0.3';
            // Visual hierarchy & pacing - Part B: Tater idle, gentle background movement
            // Reset hardening: avoid rare compositor "catch-up" sprint on background after reset
            pauseAnimations(true); // Freeze moving layers first
            void gameContainer.offsetHeight; // Force a layout sync so animation state is clean
            requestAnimationFrame(() => {
    // Apply calm factor on a clean paused frame
    setAmbientMotionFactor(AMBIENT_RAMP_START);

    // Resume animations on the next frame to prevent iOS catch-up sprint
    requestAnimationFrame(() => {
        pauseAnimations(false);
    });
});

            // RAF chain hardening: restart the loop after reset
            startGameLoop();
        }

        function gameLoop() {
            // RAF chain hardening: guard against multiple loops
            if (gameLoopRunning) return;
            gameLoopRunning = true;

            try {
            const now = Date.now();
            // Step 3 juice - skip game updates during hit-stop (CSS animations continue)
            const inHitStop = now < hitStopUntil;

            // Time-normalized horizontal movement: Windows-only dtScale
            // Non-Windows: always use dtScale=1 (no compensation needed)
            if (IS_WINDOWS) {
                const perfNowFrame = performance.now();
                let dtMs = 16.6667; // default to 60fps
                if (lastFrameTime !== null) {
                // Clamp dtMs: 10ms (~100fps) to 70ms (~14fps safety cap)
					dtMs = Math.max(10, Math.min(70, perfNowFrame - lastFrameTime));
                }
                lastFrameTime = perfNowFrame;
				// rawScale: 0.6 (fast frames) to 3.5 (handles ~17fps: 58/16.67=3.5)
				const rawScale = Math.max(0.6, Math.min(3.5, dtMs / 16.6667));
					const alpha = (rawScale > dtScaleSmoothed) ? 0.25 : 0.10;
					dtScaleSmoothed = dtScaleSmoothed + (rawScale - dtScaleSmoothed) * alpha;
                // Diagnostics (read by perf probe)
                dtMsLast = dtMs;
                dtScaleRawLast = rawScale;
            }

            // Step 4 tutorial - skip updates while tutorial is active
            // Visual hierarchy & pacing - Part B: skip updates during pre-run state
            if (!isPaused && !isGameOver && !inHitStop && !tutorialActive && !preRunState) {
                frameCount++; // Anti-cluster: increment frame counter for recovery tracking
                updateJumpCharge(); updatePhysics(); updateObstacles(IS_WINDOWS ? dtScaleSmoothed : 1);
                updateAmbientRamp(score); // CHANGE (ambient-ramp): Smooth easing each frame
                updateHighSpeedVisual(score); // CHANGE (high-speed-visual): Dampen noisy idle animations

                // Step 2.5 spawn pacing - check for pattern queue opportunity
                maybeQueuePattern();

                // Difficulty curve - get current tier for spawn timing
                const tier = getDifficultyTier(score);
                const spawnParams = getSpawnDelayParams(tier);
                const maxConsecutive = getMaxConsecutive(tier);

                // Difficulty curve - calculate spawn interval with smooth progression within tier
                // Uses tier base/min with linear interpolation based on progress through tier
                let tierProgress = 0;
                if (tier === 'EARLY') {
                    tierProgress = score / TIER_EARLY_END;
                } else if (tier === 'MID') {
                    tierProgress = (score - TIER_EARLY_END) / (TIER_MID_END - TIER_EARLY_END);
                } else {
                    // LATE tier: asymptotic approach to min
                    tierProgress = Math.min(1, (score - TIER_MID_END) / 800);
                }
                let baseSpawnInterval = spawnParams.base - (spawnParams.base - spawnParams.min) * tierProgress;

                // Step 2.5 spawn pacing - add breather delay after consecutive spawns (tier-scaled)
                if (consecutiveSpawns >= maxConsecutive) {
                    baseSpawnInterval += BREATHER_DELAY;
                }

                // Difficulty curve - post-hard-hazard breather
                const timeSinceHardHazard = now - lastHardHazardTime;
                let postHardBreather = false;
                if (lastHardHazardTime > 0 && timeSinceHardHazard < POST_HARD_BREATHER_DELAY + 500) {
                    baseSpawnInterval += POST_HARD_BREATHER_DELAY;
                    postHardBreather = true;
                }

                // Step 2.6 spawn gate accuracy - get actual next candidate for spacing check
                const nextCandidate = getNextObstacleCandidate();

                // Step 2.6 spawn gate accuracy - use actual candidate type for spacing gate
                const canSpawn = canSpawnObstacle(nextCandidate);

                // Priority 3 Difficulty Lever 1: apply spawn interval multiplier
                const effectiveSpawnInterval = baseSpawnInterval * getSpawnIntervalMultiplier(score);

                // Difficulty curve - debug logging
                if (DEBUG_DIFFICULTY && canSpawn && now - lastSpawnTime > effectiveSpawnInterval) {
                    const minSpacing = nextCandidate ? getMinSpacingPx(obstacles.length > 0 ? obstacles[obstacles.length - 1].type : null, nextCandidate) : 0;
                    logDifficulty(tier, gameSpeed, minSpacing, effectiveSpawnInterval, postHardBreather ? ' [post-hard breather]' : '');
                }

                if (now - lastSpawnTime > effectiveSpawnInterval && canSpawn) {
                    // Difficulty curve - track hard hazard spawns for breather logic
                    if (nextCandidate && isHardHazard(nextCandidate)) {
                        lastHardHazardTime = now;
                    }

                    // Step 2.6 spawn gate accuracy - spawn the same candidate we checked
                    spawnObstacle(nextCandidate);
                    lastSpawnTime = now;
                    // Step 2.5 spawn pacing - reset breather counter after breather (tier-scaled)
                    if (consecutiveSpawns >= maxConsecutive) consecutiveSpawns = 0;
                }

                // Step 2.7 powerup safety - improved powerup spawn timing
                // CHANGE (difficulty): bone spawn chance and cooldown scale with score
                const boneSpawnParams = getBoneSpawnChance(score);
                const baseCooldown = (8000 + Math.random() * 6000) * boneSpawnParams.cooldownMult;
                if (now - lastPowerupTime > baseCooldown) {
                    // Roll against spawn chance (higher score = lower chance)
                    if (Math.random() < boneSpawnParams.chance) {
                        // Step 2.7 powerup safety - find safe height BEFORE attempting spawn
                        const safeHeight = findSafeBoneHeight();
                        if (safeHeight !== null) {
                            // Step 2.7 powerup safety - pass the pre-validated safe height
                            if (spawnPowerup(safeHeight)) {
                                lastPowerupTime = now;
                            }
                        }
                    } else {
                        // Failed chance roll - still reset timer to avoid rapid re-checks
                        lastPowerupTime = now;
                    }
                }
                // Difficulty curve - smooth 3-act speed progression
                gameSpeed = calculateGameSpeed(score);
            }

            // Priority 3: Update debug HUD (throttled, no gameplay impact)
            updateDebugHud(now);

            // Windows perf probe: track frame time in ring buffer (minimal overhead)
            if (IS_WINDOWS) {
                const perfNow = performance.now();
                if (perfLastFrameTime > 0) {
                    perfRing[perfRingIdx] = perfNow - perfLastFrameTime;
                    perfRingIdx = (perfRingIdx + 1) % PERF_RING_SIZE;
                }
                perfLastFrameTime = perfNow;
                perfFrameCount++;
            }

            } finally {
                // RAF chain hardening: always release guard and schedule next frame
                gameLoopRunning = false;
                gameLoopId = requestAnimationFrame(gameLoop);
            }
        }

        // Ship-hardening: safe game loop starter (prevents double-start)
        function startGameLoop() {
            if (gameLoopId !== null) return; // Loop already running
            gameLoopRunning = false;
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // Step 3 sound - initialize audio on first user interaction
        // Desktop input - mousedown handler with UI checking (consistent with touch handlers)
        body.addEventListener('mousedown', e => {
            initAudio();
            if (isInputOnUI(e)) return; // Desktop input fix - never trigger jump on UI
            startJump();
        });
        // Desktop input - mouseup and mouseleave handlers
        body.addEventListener('mouseup', e => {
            if (isInputOnUI(e)) return;
            releaseJump();
        });
        body.addEventListener('mouseleave', releaseJump);
        // Mobile UI - mobile menu toggle functionality
        const mobileMenu = document.getElementById('mobileMenu');
        const moreBtn = document.getElementById('moreBtn');
        function toggleMobileMenu(e) {
            if (e) e.stopPropagation();
            mobileMenu.classList.toggle('show');
        }
        function closeMobileMenu() {
            mobileMenu.classList.remove('show');
        }
        // Mobile UI - close menu when clicking outside
        document.addEventListener('click', e => {
            if (!e.target.closest('.controls-wrapper')) closeMobileMenu();
        });
        document.addEventListener('touchstart', e => {
            if (!e.target.closest('.controls-wrapper') && !e.target.closest('.mobile-menu')) closeMobileMenu();
        }, { passive: true });

        // Gameplay polish - comprehensive UI selector to prevent jump on any UI element
        // Accessibility - includes toggle-switch for settings
        // Input fix - ensure .overlay-btn has proper dot prefix in selector
        // Note: .start-prompt and .hint are handled specially to allow game start
        const uiSelector = 'button, .btn, .overlay-btn, .overlay, .ui-top, .controls-wrapper, .mobile-menu, .lives-container, .score-display, .game-title, .about-btn, .version-string, .toggle-switch, label';
        // Gameplay polish - helper to check if input target is UI that should block input (works for both touch and mouse)
        function isInputOnUI(e) {
            // Ensure first gameplay input always starts the run:
            // During pre-run, allow clicks/touches on start-prompt and hint to pass through
            if (preRunState && !isAnyOverlayVisible()) {
                const onStartPrompt = e.target.closest('.start-prompt');
                const onHint = e.target.closest('.hint');
                if (onStartPrompt || onHint) {
                    return false; // Allow these inputs to trigger startJump
                }
            }
            return e.target.closest(uiSelector) !== null;
        }
        // Mobile input fix - touchstart handler ignores all UI elements
        body.addEventListener('touchstart', e => {
            initAudio();
            if (isInputOnUI(e)) return; // Input fix - never trigger jump on UI
            e.preventDefault();
            startJump();
        }, { passive: false });
        // Mobile input fix - touchend handler ignores all UI elements
        body.addEventListener('touchend', e => {
            if (isInputOnUI(e)) return; // Input fix - never trigger releaseJump on UI
            e.preventDefault();
            releaseJump();
        }, { passive: false });
        body.addEventListener('touchcancel', releaseJump);
        muteBtn.addEventListener('click', e => { e.stopPropagation(); initAudio(); toggleMute(); });
        document.getElementById('pauseBtn').addEventListener('click', e => { e.stopPropagation(); togglePause(); });
        document.getElementById('resetBtn').addEventListener('click', e => { e.stopPropagation(); resetGame(); });
        // Mobile UI - mobile reset button handler
        document.getElementById('resetBtnMobile').addEventListener('click', e => { e.stopPropagation(); closeMobileMenu(); resetGame(); });
        // Mobile UI - more menu button handler
        moreBtn.addEventListener('click', toggleMobileMenu);
        document.getElementById('resumeBtn').addEventListener('click', e => { e.stopPropagation(); togglePause(); });
        document.getElementById('restartBtn').addEventListener('click', e => { e.stopPropagation(); resetGame(); });
        // Game-over polish - Part E: Tap overlay background to restart
        gameOverOverlay.addEventListener('click', e => {
            // Only restart if clicking the overlay background, not the content or buttons
            if (e.target === gameOverOverlay || e.target.classList.contains('tap-hint')) {
                resetGame();
            }
        });
        // Step 4 tutorial - tutorial button event listener
        document.getElementById('tutorialBtn').addEventListener('click', e => { e.stopPropagation(); initAudio(); dismissTutorial(); });
        // Share polish - About button event listeners
        document.getElementById('aboutBtn').addEventListener('click', e => { e.stopPropagation(); showAbout(); });
        document.getElementById('aboutCloseBtn').addEventListener('click', e => { e.stopPropagation(); hideAbout(); });
        // Accessibility - Settings button event listeners
        document.getElementById('settingsBtnMobile').addEventListener('click', e => { e.stopPropagation(); closeMobileMenu(); showSettings(); });
        document.getElementById('settingsCloseBtn').addEventListener('click', e => { e.stopPropagation(); hideSettings(); });
        // UI polish - Help button in settings
        document.getElementById('helpBtn').addEventListener('click', e => { e.stopPropagation(); showHelp(); });

        // Accessibility - Keyboard support (guarded to prevent duplicate binding)
        if (window.__taterKeyHandlersBound) {
            console.warn('[SHIP] Keyboard handlers already bound - skipping duplicate registration');
        } else {
            window.__taterKeyHandlersBound = true;
            document.addEventListener('keydown', e => {
                // Ignore if typing in an input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                // Space or Enter: start jump (hold)
                if (e.code === 'Space' || e.code === 'Enter') {
                    e.preventDefault();
                    if (e.repeat) return; // Ignore key repeat to prevent charge meter flicker
                    initAudio();
                    startJump();
                }
                // P: toggle pause
                if (e.code === 'KeyP') {
                    e.preventDefault();
                    togglePause();
                }
                // R: restart game
                if (e.code === 'KeyR') {
                    e.preventDefault();
                    resetGame();
                }
                // Escape: close any open overlay
                if (e.code === 'Escape') {
                    e.preventDefault();
                    hideAbout();
                    hideSettings();
                    if (isPaused && !isGameOver) togglePause();
                }
                // D: toggle debug HUD (developer only)
                if (e.code === 'KeyD') {
                    debugHudVisible = !debugHudVisible;
                    document.getElementById('debugHud').classList.toggle('show', debugHudVisible);
                }
            });

            document.addEventListener('keyup', e => {
                // Space or Enter: release jump
                if (e.code === 'Space' || e.code === 'Enter') {
                    e.preventDefault();
                    releaseJump();
                }
            });
        }

        body.addEventListener('contextmenu', e => e.preventDefault());
        body.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

        // Auto-pause on focus loss / tab hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) forcePause();
        });
        window.addEventListener('blur', () => forcePause());

        // Priority 2 (ship safety): Console-only sanity checks for common regressions
        function runShipSanityChecks() {
            if (!document.getElementById('versionString')) {
                console.warn('[SHIP] Missing element: #versionString');
            }
            if (!document.getElementById('debugHud')) {
                console.warn('[SHIP] Missing element: #debugHud');
            }
            const versionElements = document.querySelectorAll('.version-string');
            if (versionElements.length !== 1) {
                console.warn('[SHIP] Expected exactly 1 .version-string element, found:', versionElements.length);
            }
            if (document.documentElement.outerHTML.includes('v0.1')) {
                console.warn('[SHIP] Hardcoded "v0.1" found in HTML - should use GAME_VERSION constant');
            }
        }

        // Step 4 tutorial - show tutorial on first run, then start game loop
        // Visual hierarchy & pacing - Part B: Show start prompt if no tutorial
        generateBackground(); initLives();
        document.getElementById('versionString').textContent = GAME_VERSION;

        applyBaseYToTater(true);

        // Mobile baseline: keep band aligned on resize/orientation
        // Re-anchors Tater + all obstacles + all powerups to new baseline offset
        let prevBaselineOffset = getMobileBaselineOffset();
        let resizeDebounceTimer = null;

        function handleViewportChange() {
            // Debounce to avoid thrashing during resize drag
            if (resizeDebounceTimer) clearTimeout(resizeDebounceTimer);
            resizeDebounceTimer = setTimeout(() => {
                requestAnimationFrame(() => {
                    const newOffset = getMobileBaselineOffset();

                    // Skip if offset didn't change (most resize events)
                    if (newOffset === prevBaselineOffset) return;

                    // Update baseline (no physics reset)
                    prevBaselineOffset = newOffset;
                    baseY = getBaseY();

                    // Re-anchor Tater (preserves mid-jump position via taterY)
                    taterContainer.style.bottom = (baseY + (taterY / window.innerHeight) * 100) + '%';

                    // Re-anchor all existing obstacles from stored groundY
                    for (const o of obstacles) {
                        if (o.element && o.type) {
                            o.element.style.bottom = (o.type.groundY + newOffset) + '%';
                        }
                    }

                    // Re-anchor all existing powerups from stored height
                    for (const p of powerups) {
                        if (p.element && p.height !== undefined) {
                            p.element.style.bottom = (p.height + newOffset) + '%';
                        }
                    }
                });
            }, 120);
        }

        window.addEventListener('resize', handleViewportChange);
        window.addEventListener('orientationchange', handleViewportChange);

        runShipSanityChecks(); // Priority 2: Run sanity checks before game starts
        if (!tutorialActive) {
            startPrompt.classList.add('show');
        }
        showTutorial(); startGameLoop();
        // REMOVED: SAFETY START FIX block â€” startJump() already handles preRunState transition
    </script>
</body>
</html>
